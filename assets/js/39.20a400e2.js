(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{414:function(s,t,a){"use strict";a.r(t);var e=a(2),n=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("除了之前介绍过的 "),t("RouterLink",{attrs:{to:"/pages/279dd7/"}},[s._v("基本运算符")]),s._v("，Swift 还提供了数种可以对数值进行复杂运算的高级运算符。它们包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。")],1),s._v(" "),t("p",[s._v("与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运算符（"),t("code",[s._v("&+")]),s._v("）。所有的这些溢出运算符都是以 "),t("code",[s._v("&")]),s._v(" 开头的。")]),s._v(" "),t("p",[s._v("自定义结构体、类和枚举时，如果也为它们提供标准 Swift 运算符的实现，将会非常有用。在 Swift 中为这些运算符提供自定义的实现非常简单，运算符也会针对不同类型使用对应实现。")]),s._v(" "),t("p",[s._v("我们不用被预定义的运算符所限制。在 Swift 中可以自由地定义中缀、前缀、后缀和赋值运算符，它们具有自定义的优先级与关联值。这些运算符在代码中可以像预定义的运算符一样使用，你甚至可以扩展已有的类型以支持自定义运算符。")]),s._v(" "),t("h2",{attrs:{id:"位运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#位运算符"}},[s._v("#")]),s._v(" 位运算符")]),s._v(" "),t("p",[t("em",[s._v("位运算符")]),s._v("可以操作数据结构中每个独立的比特位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。")]),s._v(" "),t("p",[s._v("Swift 支持 C 语言中的全部位运算符，接下来会一一介绍。")]),s._v(" "),t("h3",{attrs:{id:"bitwise-not-operator（按位取反运算符）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitwise-not-operator（按位取反运算符）"}},[s._v("#")]),s._v(" Bitwise NOT Operator（按位取反运算符）")]),s._v(" "),t("p",[t("em",[s._v("按位取反运算符（"),t("strong",[t("code",[s._v("~")])]),s._v("）")]),s._v(" 对一个数值的全部比特位进行取反：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111145.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitwiseNOT_2x.png")]),s._v(" "),t("p",[s._v("按位取反运算符是一个前缀运算符，直接放在运算数之前，并且它们之间不能添加任何空格：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" initialBits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0b00001111")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" invertedBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("~")]),s._v("initialBits "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 等于 0b11110000")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[t("code",[s._v("UInt8")]),s._v(" 类型的整数有 8 个比特位，可以存储 "),t("code",[s._v("0 ~ 255")]),s._v(" 之间的任意整数。这个例子初始化了一个 "),t("code",[s._v("UInt8")]),s._v(" 类型的整数，并赋值为二进制的 "),t("code",[s._v("00001111")]),s._v("，它的前 4 位为 "),t("code",[s._v("0")]),s._v("，后 4 位为 "),t("code",[s._v("1")]),s._v("。这个值等价于十进制的 "),t("code",[s._v("15")]),s._v("。")]),s._v(" "),t("p",[s._v("接着使用按位取反运算符创建了一个名为 "),t("code",[s._v("invertedBits")]),s._v(" 的常量，这个常量的值与全部位取反后的 "),t("code",[s._v("initialBits")]),s._v(" 相等。即所有的 "),t("code",[s._v("0")]),s._v(" 都变成了 "),t("code",[s._v("1")]),s._v("，同时所有的 "),t("code",[s._v("1")]),s._v(" 都变成 "),t("code",[s._v("0")]),s._v("。"),t("code",[s._v("invertedBits")]),s._v(" 的二进制值为 "),t("code",[s._v("11110000")]),s._v("，等价于无符号十进制数的 "),t("code",[s._v("240")]),s._v("。")]),s._v(" "),t("h3",{attrs:{id:"bitwise-and-operator（按位与运算符）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitwise-and-operator（按位与运算符）"}},[s._v("#")]),s._v(" Bitwise AND Operator（按位与运算符）")]),s._v(" "),t("p",[t("em",[s._v("按位与运算符（"),t("strong",[t("code",[s._v("&")])]),s._v("）")]),s._v(" 对两个数的比特位进行合并。它返回一个新的数，只有当两个数的对应位"),t("em",[s._v("都")]),s._v("为 "),t("code",[s._v("1")]),s._v(" 的时候，新数的对应位才为 "),t("code",[s._v("1")]),s._v("：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111157.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitwiseAND_2x.png")]),s._v(" "),t("p",[s._v("在下面的示例当中，"),t("code",[s._v("firstSixBits")]),s._v(" 和 "),t("code",[s._v("lastSixBits")]),s._v(" 中间 4 个位的值都为 "),t("code",[s._v("1")]),s._v("。使用按位与运算符之后，得到二进制数值 "),t("code",[s._v("00111100")]),s._v("，等价于无符号十进制数的 "),t("code",[s._v("60")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" firstSixBits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0b11111100")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" lastSixBits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),s._v("  "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0b00111111")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" middleFourBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" firstSixBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&")]),s._v(" lastSixBits "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 等于 00111100")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("h3",{attrs:{id:"bitwise-or-operator（按位或运算符）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitwise-or-operator（按位或运算符）"}},[s._v("#")]),s._v(" Bitwise OR Operator（按位或运算符）")]),s._v(" "),t("p",[t("em",[s._v("按位或运算符（"),t("strong",[t("code",[s._v("|")])]),s._v("）")]),s._v(" 可以对两个数的比特位进行比较。它返回一个新的数，只要两个数的对应位中有"),t("em",[s._v("任意一个")]),s._v("为 "),t("code",[s._v("1")]),s._v(" 时，新数的对应位就为 "),t("code",[s._v("1")]),s._v("：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111214.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitwiseOR_2x.png")]),s._v(" "),t("p",[s._v("在下面的示例中，"),t("code",[s._v("someBits")]),s._v(" 和 "),t("code",[s._v("moreBits")]),s._v(" 存在不同的位被设置为 "),t("code",[s._v("1")]),s._v("。使用按位或运算符之后，得到二进制数值 "),t("code",[s._v("11111110")]),s._v("，等价于无符号十进制数的 "),t("code",[s._v("254")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" someBits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0b10110010")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" moreBits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0b01011110")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" combinedbits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" someBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" moreBits "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 等于 11111110")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("h3",{attrs:{id:"bitwise-xor-operator（按位异或运算符）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitwise-xor-operator（按位异或运算符）"}},[s._v("#")]),s._v(" Bitwise XOR Operator（按位异或运算符）")]),s._v(" "),t("p",[t("em",[s._v("按位异或运算符")]),s._v("，或称“排外的或运算符”（"),t("code",[s._v("^")]),s._v("），可以对两个数的比特位进行比较。它返回一个新的数，当两个数的对应位不相同时，新数的对应位就为 "),t("code",[s._v("1")]),s._v("，并且对应位相同时则为 "),t("code",[s._v("0")]),s._v("：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111224.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitwiseXOR_2x.png")]),s._v(" "),t("p",[s._v("在下面的示例当中，"),t("code",[s._v("firstBits")]),s._v(" 和 "),t("code",[s._v("otherBits")]),s._v(" 都有一个自己为 "),t("code",[s._v("1")]),s._v("，而对方为 "),t("code",[s._v("0")]),s._v(" 的位。按位异或运算符将新数的这两个位都设置为 "),t("code",[s._v("1")]),s._v("。在其余的位上 "),t("code",[s._v("firstBits")]),s._v(" 和 "),t("code",[s._v("otherBits")]),s._v(" 是相同的，所以设置为 "),t("code",[s._v("0")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" firstBits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0b00010100")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" otherBits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0b00000101")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" outputBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" firstBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("^")]),s._v(" otherBits "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 等于 00010001")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("h3",{attrs:{id:"bitwise-left-and-right-shift-operators（按位左移、右移运算符）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitwise-left-and-right-shift-operators（按位左移、右移运算符）"}},[s._v("#")]),s._v(" Bitwise Left and Right Shift Operators（按位左移、右移运算符）")]),s._v(" "),t("p",[t("em",[s._v("按位左移运算符（"),t("strong",[t("code",[s._v("<<")])]),s._v("）")]),s._v(" 和 "),t("em",[s._v("按位右移运算符（"),t("strong",[t("code",[s._v(">>")])]),s._v("）")]),s._v(" 可以对一个数的所有位进行指定位数的左移和右移，但是需要遵守下面定义的规则。")]),s._v(" "),t("p",[s._v("对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。")]),s._v(" "),t("h4",{attrs:{id:"无符号整数的移位运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无符号整数的移位运算"}},[s._v("#")]),s._v(" 无符号整数的移位运算")]),s._v(" "),t("p",[s._v("对无符号整数进行移位的规则如下：")]),s._v(" "),t("ol",[t("li",[s._v("已存在的位按指定的位数进行左移和右移。")]),s._v(" "),t("li",[s._v("任何因移动而超出整型存储范围的位都会被丢弃。")]),s._v(" "),t("li",[s._v("用 "),t("code",[s._v("0")]),s._v(" 来填充移位后产生的空白位。")])]),s._v(" "),t("p",[s._v("这种方法称为"),t("em",[s._v("逻辑移位")]),s._v("。")]),s._v(" "),t("p",[s._v("以下这张图展示了 "),t("code",[s._v("11111111 << 1")]),s._v("（即把 "),t("code",[s._v("11111111")]),s._v(" 向左移动 "),t("code",[s._v("1")]),s._v(" 位），和 "),t("code",[s._v("11111111 >> 1")]),s._v("（即把 "),t("code",[s._v("11111111")]),s._v(" 向右移动 "),t("code",[s._v("1")]),s._v(" 位）的结果。蓝色的数字是被移位的，灰色的数字是被抛弃的，橙色的 "),t("code",[s._v("0")]),s._v(" 则是被填充进来的：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111236.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitshiftUnsigned_2x.png")]),s._v(" "),t("p",[s._v("下面的代码演示了 Swift 中的移位运算：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" shiftBits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 即二进制的 00000100")]),s._v("\nshiftBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<<")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("           "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 00001000")]),s._v("\nshiftBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<<")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("           "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 00010000")]),s._v("\nshiftBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<<")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v("           "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 10000000")]),s._v("\nshiftBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<<")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("6")]),s._v("           "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 00000000")]),s._v("\nshiftBits "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("           "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 00000001")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("可以使用移位运算对其他的数据类型进行编码和解码：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" pink"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt32")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0xCC6699")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" redComponent "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("pink "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0xFF0000")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("16")]),s._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// redComponent 是 0xCC，即 204")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" greenComponent "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("pink "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x00FF00")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">>")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// greenComponent 是 0x66， 即 102")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" blueComponent "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" pink "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0x0000FF")]),s._v("         "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// blueComponent 是 0x99，即 153")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("这个示例使用了一个命名为 "),t("code",[s._v("pink")]),s._v(" 的 "),t("code",[s._v("UInt32")]),s._v(" 型常量来存储 Cascading Style Sheets（CSS）中粉色的颜色值。该 CSS 的颜色值 "),t("code",[s._v("#CC6699")]),s._v("，在 Swift 中表示为十六进制的 "),t("code",[s._v("0xCC6699")]),s._v("。然后利用按位与运算符（"),t("code",[s._v("&")]),s._v("）和按位右移运算符（"),t("code",[s._v(">>")]),s._v("）从这个颜色值中分解出红（"),t("code",[s._v("CC")]),s._v("）、绿（"),t("code",[s._v("66")]),s._v("）以及蓝（"),t("code",[s._v("99")]),s._v("）三个部分。")]),s._v(" "),t("p",[s._v("红色部分是通过对 "),t("code",[s._v("0xCC6699")]),s._v(" 和 "),t("code",[s._v("0xFF0000")]),s._v(" 进行按位与运算后得到的。"),t("code",[s._v("0xFF0000")]),s._v(" 中的 "),t("code",[s._v("0")]),s._v(" 部分“掩盖”了 "),t("code",[s._v("OxCC6699")]),s._v(" 中的第二、第三个字节，使得数值中的 "),t("code",[s._v("6699")]),s._v(" 被忽略，只留下 "),t("code",[s._v("0xCC0000")]),s._v("。")]),s._v(" "),t("p",[s._v("然后，将这个数向右移动 16 位（"),t("code",[s._v(">> 16")]),s._v("）。十六进制中每两个字符占用 8 个比特位，所以移动 16 位后 "),t("code",[s._v("0xCC0000")]),s._v(" 就变为 "),t("code",[s._v("0x0000CC")]),s._v("。这个数和 "),t("code",[s._v("0xCC")]),s._v(" 是等同的，也就是十进制数值的 "),t("code",[s._v("204")]),s._v("。")]),s._v(" "),t("p",[s._v("同样的，绿色部分通过对 "),t("code",[s._v("0xCC6699")]),s._v(" 和 "),t("code",[s._v("0x00FF00")]),s._v(" 进行按位与运算得到 "),t("code",[s._v("0x006600")]),s._v("。然后将这个数向右移动 8 位，得到 "),t("code",[s._v("0x66")]),s._v("，也就是十进制数值的 "),t("code",[s._v("102")]),s._v("。")]),s._v(" "),t("p",[s._v("最后，蓝色部分通过对 "),t("code",[s._v("0xCC6699")]),s._v(" 和 "),t("code",[s._v("0x0000FF")]),s._v(" 进行按位与运算得到 "),t("code",[s._v("0x000099")]),s._v("。这里不需要再向右移位，而 "),t("code",[s._v("0x000099")]),s._v(" 也就是 "),t("code",[s._v("0x99")]),s._v(" ，也就是十进制数值的 "),t("code",[s._v("153")]),s._v("。")]),s._v(" "),t("h4",{attrs:{id:"有符号整数的移位运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有符号整数的移位运算"}},[s._v("#")]),s._v(" 有符号整数的移位运算")]),s._v(" "),t("p",[s._v("对比无符号整数，有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。（为了简单起见，以下的示例都是基于 8 比特的有符号整数，但是其中的原理对任何位数的有符号整数都是通用的。）")]),s._v(" "),t("p",[s._v("有符号整数使用第 1 个比特位（通常被称为"),t("em",[s._v("符号位")]),s._v("）来表示这个数的正负。符号位为 "),t("code",[s._v("0")]),s._v(" 代表正数，为 "),t("code",[s._v("1")]),s._v(" 代表负数。")]),s._v(" "),t("p",[s._v("其余的比特位（通常被称为"),t("em",[s._v("数值位")]),s._v("）存储了实际的值。有符号正整数和无符号数的存储方式是一样的，都是从 "),t("code",[s._v("0")]),s._v(" 开始算起。这是值为 "),t("code",[s._v("4")]),s._v(" 的 "),t("code",[s._v("Int8")]),s._v(" 型整数的二进制位表现形式：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111250.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitshiftSignedFour_2x.png")]),s._v(" "),t("p",[s._v("符号位为 "),t("code",[s._v("0")]),s._v("（代表这是一个“正数”），另外 7 位则代表了十进制数值 "),t("code",[s._v("4")]),s._v(" 的二进制表示。")]),s._v(" "),t("p",[s._v("负数的存储方式略有不同。它存储 "),t("code",[s._v("2")]),s._v(" 的 "),t("code",[s._v("n")]),s._v(" 次方减去其实际值的绝对值，这里的 "),t("code",[s._v("n")]),s._v(" 是数值位的位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 "),t("code",[s._v("2")]),s._v(" 的 "),t("code",[s._v("7")]),s._v(" 次方，即 "),t("code",[s._v("128")]),s._v("。")]),s._v(" "),t("p",[s._v("这是值为 "),t("code",[s._v("-4")]),s._v(" 的 "),t("code",[s._v("Int8")]),s._v(" 型整数的二进制表现形式：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111259.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitshiftSignedMinusFour_2x.png")]),s._v(" "),t("p",[s._v("这次的符号位为 "),t("code",[s._v("1")]),s._v("，说明这是一个负数，另外 7 个位则代表了数值 "),t("code",[s._v("124")]),s._v("（即 "),t("code",[s._v("128 - 4")]),s._v("）的二进制表示：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111318.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitshiftSignedMinusFourValue_2x.png")]),s._v(" "),t("p",[s._v("负数的表示通常被称为"),t("em",[s._v("二进制补码")]),s._v("。用这种方法来表示负数乍看起来有点奇怪，但它有几个优点。")]),s._v(" "),t("p",[s._v("首先，如果想对 "),t("code",[s._v("-1")]),s._v(" 和 "),t("code",[s._v("-4")]),s._v(" 进行加法运算，我们只需要对这两个数的全部 8 个比特位执行标准的二进制相加（包括符号位），并且将计算结果中超出 8 位的数值丢弃：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111330.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitshiftSignedAddition_2x.png")]),s._v(" "),t("p",[s._v("其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：当对有符号整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用"),t("em",[s._v("符号位")]),s._v("进行填充，而不是用 "),t("code",[s._v("0")]),s._v("。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111344.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/bitshiftSigned_2x.png")]),s._v(" "),t("p",[s._v("这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为"),t("em",[s._v("算术移位")]),s._v("。")]),s._v(" "),t("p",[s._v("由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 "),t("code",[s._v("0")]),s._v("。在移位的过程中保持符号位不变，意味着负整数在接近 "),t("code",[s._v("0")]),s._v(" 的过程中会一直保持为负。")]),s._v(" "),t("h2",{attrs:{id:"溢出运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#溢出运算符"}},[s._v("#")]),s._v(" 溢出运算符")]),s._v(" "),t("p",[s._v("当向一个整数类型的常量或者变量赋予超过它容量的值时，Swift 默认会报错，而不是允许生成一个无效的数。这个行为为我们在运算过大或者过小的数时提供了额外的安全性。")]),s._v(" "),t("p",[s._v("例如，"),t("code",[s._v("Int16")]),s._v(" 型整数能容纳的有符号整数范围是 "),t("code",[s._v("-32768")]),s._v(" 到 "),t("code",[s._v("32767")]),s._v("。当为一个 "),t("code",[s._v("Int16")]),s._v(" 类型的变量或常量赋予的值超过这个范围时，系统就会报错：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" potentialOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Int16")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("max\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数")]),s._v("\npotentialOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 这里会报错")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("在赋值时为过大或者过小的情况提供错误处理，能让我们在处理边界值时更加灵活。")]),s._v(" "),t("p",[s._v("然而，当你希望的时候也可以选择让系统在数值溢出的时候采取截断处理，而非报错。Swift 提供的三个"),t("em",[s._v("溢出运算符")]),s._v("来让系统支持整数溢出运算。这些运算符都是以 "),t("code",[s._v("&")]),s._v(" 开头的：")]),s._v(" "),t("ul",[t("li",[s._v("溢出加法 "),t("code",[s._v("&+")])]),s._v(" "),t("li",[s._v("溢出减法 "),t("code",[s._v("&-")])]),s._v(" "),t("li",[s._v("溢出乘法 "),t("code",[s._v("&*")])])]),s._v(" "),t("h3",{attrs:{id:"数值溢出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数值溢出"}},[s._v("#")]),s._v(" 数值溢出")]),s._v(" "),t("p",[s._v("数值有可能出现上溢或者下溢。")]),s._v(" "),t("p",[s._v("这个示例演示了当我们对一个无符号整数使用溢出加法（"),t("code",[s._v("&+")]),s._v("）进行上溢运算时会发生什么：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" unsignedOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("max\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255")]),s._v("\nunsignedOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" unsignedOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 此时 unsignedOverflow 等于 0")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[t("code",[s._v("unsignedOverflow")]),s._v(" 被初始化为 "),t("code",[s._v("UInt8")]),s._v(" 所能容纳的最大整数（"),t("code",[s._v("255")]),s._v("，以二进制表示即 "),t("code",[s._v("11111111")]),s._v("）。然后使用溢出加法运算符（"),t("code",[s._v("&+")]),s._v("）对其进行加 "),t("code",[s._v("1")]),s._v(" 运算。这使得它的二进制表示正好超出 "),t("code",[s._v("UInt8")]),s._v(" 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，仍然留在 "),t("code",[s._v("UInt8")]),s._v(" 边界内的值是 "),t("code",[s._v("00000000")]),s._v("，也就是十进制数值的 "),t("code",[s._v("0")]),s._v("。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111355.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/overflowAddition_2x.png")]),s._v(" "),t("p",[s._v("当允许对一个无符号整数进行下溢运算时也会产生类似的情况。这里有一个使用溢出减法运算符（"),t("code",[s._v("&-")]),s._v("）的例子：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" unsignedOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("UInt8")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("min\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0")]),s._v("\nunsignedOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" unsignedOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 此时 unsignedOverflow 等于 255")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[t("code",[s._v("UInt8")]),s._v(" 型整数能容纳的最小值是 "),t("code",[s._v("0")]),s._v("，以二进制表示即 "),t("code",[s._v("00000000")]),s._v("。当使用溢出减法运算符对其进行减 "),t("code",[s._v("1")]),s._v(" 运算时，数值会产生下溢并被截断为 "),t("code",[s._v("11111111")]),s._v("， 也就是十进制数值的 "),t("code",[s._v("255")]),s._v("。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111406.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/overflowUnsignedSubtraction_2x.png")]),s._v(" "),t("p",[s._v("溢出也会发生在有符号整型上。针对有符号整型的所有溢出加法或者减法运算都是按位运算的方式执行的，符号位也需要参与计算，正如 "),t("RouterLink",{attrs:{to:"/pages/9854b9/#bitwise-xor-operator（按位异或运算符）"}},[s._v("按位左移、右移运算符")]),s._v(" 所描述的。")],1),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" signedOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Int8")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("min\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// signedOverflow 等于 Int8 所能容纳的最小整数 -128")]),s._v("\nsignedOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" signedOverflow "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 此时 signedOverflow 等于 127")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[t("code",[s._v("Int8")]),s._v(" 型整数能容纳的最小值是 "),t("code",[s._v("-128")]),s._v("，以二进制表示即 "),t("code",[s._v("10000000")]),s._v("。当使用溢出减法运算符对其进行减 "),t("code",[s._v("1")]),s._v(" 运算时，符号位被翻转，得到二进制数值 "),t("code",[s._v("01111111")]),s._v("，也就是十进制数值的 "),t("code",[s._v("127")]),s._v("，这个值也是 "),t("code",[s._v("Int8")]),s._v(" 型整所能容纳的最大值。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111423.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/overflowSignedSubtraction_2x.png")]),s._v(" "),t("p",[s._v("对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大数。")]),s._v(" "),t("h2",{attrs:{id:"优先级和结合性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先级和结合性"}},[s._v("#")]),s._v(" 优先级和结合性")]),s._v(" "),t("p",[s._v("运算符的"),t("em",[s._v("优先级")]),s._v("使得一些运算符优先于其他运算符；它们会先被执行。")]),s._v(" "),t("p",[t("em",[s._v("结合性")]),s._v("定义了相同优先级的运算符是如何结合的，也就是说，是与左边结合为一组，还是与右边结合为一组。可以将其理解为“它们是与左边的表达式结合的”，或者“它们是与右边的表达式结合的”。")]),s._v(" "),t("p",[s._v("当考虑一个复合表达式的计算顺序时，运算符的优先级和结合性是非常重要的。举例来说，运算符优先级解释了为什么下面这个表达式的运算结果会是 "),t("code",[s._v("17")]),s._v("。")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 结果是 17")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("如果你直接从左到右进行运算，你可能认为运算的过程是这样的：")]),s._v(" "),t("ul",[t("li",[s._v("2 + 3 = 5")]),s._v(" "),t("li",[s._v("5 % 4 = 1")]),s._v(" "),t("li",[s._v("1 * 5 = 5")])]),s._v(" "),t("p",[s._v("但是正确答案是 "),t("code",[s._v("17")]),s._v(" 而不是 "),t("code",[s._v("5")]),s._v("。优先级高的运算符要先于优先级低的运算符进行计算。与 C 语言类似，在 Swift 中，乘法运算符（"),t("code",[s._v("*")]),s._v("）与取余运算符（"),t("code",[s._v("%")]),s._v("）的优先级高于加法运算符（"),t("code",[s._v("+")]),s._v("）。因此，它们的计算顺序要先于加法运算。")]),s._v(" "),t("p",[s._v("而乘法运算与取余运算的优先级"),t("em",[s._v("相同")]),s._v("。这时为了得到正确的运算顺序，还需要考虑结合性。乘法运算与取余运算都是左结合的。可以将这考虑成，从它们的左边开始为这两部分表达式都隐式地加上括号：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[t("code",[s._v("(3 % 4)")]),s._v(" 等于 "),t("code",[s._v("3")]),s._v("，所以表达式相当于：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[t("code",[s._v("3 * 5")]),s._v(" 等于 "),t("code",[s._v("15")]),s._v("，所以表达式相当于：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("15")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("因此计算结果为 "),t("code",[s._v("17")]),s._v("。")]),s._v(" "),t("p",[s._v("有关 Swift 标准库提供的操作符信息，包括操作符优先级组和结核性设置的完整列表，请参见 "),t("a",{attrs:{href:"https://developer.apple.com/documentation/swift/operator_declarations",target:"_blank",rel:"noopener noreferrer"}},[s._v("操作符声明"),t("OutboundLink")],1),s._v("。")]),s._v(" "),t("blockquote",[t("p",[s._v("注意")]),s._v(" "),t("p",[s._v("相对 C 语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则更加简洁和可预测。但是，这也意味着它们相较于 C 语言及其衍生语言并不是完全一致。在对现有的代码进行移植的时候，要注意确保运算符的行为仍然符合你的预期。")])]),s._v(" "),t("h2",{attrs:{id:"运算符函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运算符函数"}},[s._v("#")]),s._v(" 运算符函数")]),s._v(" "),t("p",[s._v("类和结构体可以为现有的运算符提供自定义的实现。这通常被称为运算符"),t("em",[s._v("重载")]),s._v("。")]),s._v(" "),t("p",[s._v("下面的例子展示了如何让自定义的结构体支持加法运算符（"),t("code",[s._v("+")]),s._v("）。算术加法运算符是一个"),t("em",[s._v("二元运算符")]),s._v("，因为它是对两个值进行运算，同时它还可以称为"),t("em",[s._v("中缀")]),s._v("运算符，因为它出现在两个值中间。")]),s._v(" "),t("p",[s._v("例子中定义了一个名为 "),t("code",[s._v("Vector2D")]),s._v(" 的结构体用来表示二维坐标向量 "),t("code",[s._v("(x, y)")]),s._v("，紧接着定义了一个可以将两个 "),t("code",[s._v("Vector2D")]),s._v(" 结构体实例进行相加的"),t("em",[s._v("运算符函数")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" x "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extension")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("->")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("x "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("y "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("p",[s._v("该运算符函数被定义为 "),t("code",[s._v("Vector2D")]),s._v(" 上的一个类方法，并且函数的名字与它要进行重载的 "),t("code",[s._v("+")]),s._v(" 名字一致。因为加法运算并不是一个向量必需的功能，所以这个类方法被定义在 "),t("code",[s._v("Vector2D")]),s._v(" 的一个扩展中，而不是 "),t("code",[s._v("Vector2D")]),s._v(" 结构体声明内。而算术加法运算符是二元运算符，所以这个运算符函数接收两个类型为 "),t("code",[s._v("Vector2D")]),s._v(" 的参数，同时有一个 "),t("code",[s._v("Vector2D")]),s._v(" 类型的返回值。")]),s._v(" "),t("p",[s._v("在这个实现中，输入参数分别被命名为 "),t("code",[s._v("left")]),s._v(" 和 "),t("code",[s._v("right")]),s._v("，代表在 "),t("code",[s._v("+")]),s._v(" 运算符左边和右边的两个 "),t("code",[s._v("Vector2D")]),s._v(" 实例。函数返回了一个新的 "),t("code",[s._v("Vector2D")]),s._v(" 实例，这个实例的 "),t("code",[s._v("x")]),s._v(" 和 "),t("code",[s._v("y")]),s._v(" 分别等于作为参数的两个实例的 "),t("code",[s._v("x")]),s._v(" 和 "),t("code",[s._v("y")]),s._v(" 的值之和。")]),s._v(" "),t("p",[s._v("这个类方法可以在任意两个 "),t("code",[s._v("Vector2D")]),s._v(" 实例中间作为中缀运算符来使用：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" vector "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" anotherVector "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" combinedVector "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" vector "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" anotherVector\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("这个例子实现两个向量 "),t("code",[s._v("(3.0，1.0)")]),s._v(" 和 "),t("code",[s._v("(2.0，4.0)")]),s._v(" 的相加，并得到新的向量 "),t("code",[s._v("(5.0，5.0)")]),s._v("。这个过程如下图示：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20201111111444.png",alt:"img"}})]),s._v(" "),t("p",[s._v("Art/vectorAddition_2x.png")]),s._v(" "),t("h3",{attrs:{id:"前缀和后缀运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前缀和后缀运算符"}},[s._v("#")]),s._v(" 前缀和后缀运算符")]),s._v(" "),t("p",[s._v("上个例子演示了一个二元中缀运算符的自定义实现。类与结构体也能提供标准"),t("em",[s._v("一元运算符")]),s._v("的实现。一元运算符只运算一个值。当运算符出现在值之前时，它就是"),t("em",[s._v("前缀")]),s._v("的（例如 "),t("code",[s._v("-a")]),s._v("），而当它出现在值之后时，它就是"),t("em",[s._v("后缀")]),s._v("的（例如 "),t("code",[s._v("b!")]),s._v("）。")]),s._v(" "),t("p",[s._v("要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 "),t("code",[s._v("func")]),s._v(" 关键字之前指定 "),t("code",[s._v("prefix")]),s._v(" 或者 "),t("code",[s._v("postfix")]),s._v(" 修饰符：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extension")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("prefix")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("vector"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("->")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("vector"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("vector"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("这段代码为 "),t("code",[s._v("Vector2D")]),s._v(" 类型实现了一元运算符（"),t("code",[s._v("-a")]),s._v("）。由于该运算符是前缀运算符，所以这个函数需要加上 "),t("code",[s._v("prefix")]),s._v(" 修饰符。")]),s._v(" "),t("p",[s._v("对于简单数值，一元负号运算符可以对它们的正负性进行改变。对于 "),t("code",[s._v("Vector2D")]),s._v(" 来说，该运算将其 "),t("code",[s._v("x")]),s._v(" 和 "),t("code",[s._v("y")]),s._v(" 属性的正负性都进行了改变：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" positive "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" negative "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("positive\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" alsoPositive "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("negative\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h3",{attrs:{id:"复合赋值运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复合赋值运算符"}},[s._v("#")]),s._v(" 复合赋值运算符")]),s._v(" "),t("p",[t("em",[s._v("复合赋值运算符")]),s._v("将赋值运算符（"),t("code",[s._v("=")]),s._v("）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（"),t("code",[s._v("+=")]),s._v("）。在实现的时候，需要把运算符的左参数设置成 "),t("code",[s._v("inout")]),s._v(" 类型，因为这个参数的值会在运算符函数内直接被修改。")]),s._v(" "),t("p",[s._v("在下面的例子中，对 "),t("code",[s._v("Vector2D")]),s._v(" 实例实现了一个加法赋值运算符函数：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extension")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("inout")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" original "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" vectorToAdd "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\noriginal "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+=")]),s._v(" vectorToAdd\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// original 的值现在为 (4.0, 6.0)")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("blockquote",[t("p",[s._v("注意")]),s._v(" "),t("p",[s._v("不能对默认的赋值运算符（"),t("code",[s._v("=")]),s._v("）进行重载。只有复合赋值运算符可以被重载。同样地，也无法对三元条件运算符 （"),t("code",[s._v("a ? b : c")]),s._v("） 进行重载。")])]),s._v(" "),t("h3",{attrs:{id:"等价运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#等价运算符"}},[s._v("#")]),s._v(" 等价运算符")]),s._v(" "),t("p",[s._v("通常情况下，自定义的类和结构体没有对"),t("em",[s._v("等价运算符")]),s._v("进行默认实现，等价运算符通常被称为"),t("em",[s._v("相等")]),s._v("运算符（"),t("code",[s._v("==")]),s._v("）与"),t("em",[s._v("不等")]),s._v("运算符（"),t("code",[s._v("!=")]),s._v("）。")]),s._v(" "),t("p",[s._v("为了使用等价运算符对自定义的类型进行判等运算，需要为“相等”运算符提供自定义实现，实现的方法与其它中缀运算符一样, 并且增加对标准库 "),t("code",[s._v("Equatable")]),s._v(" 协议的遵循：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extension")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Equatable")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("->")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Bool")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("x "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("y "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("上述代码实现了“相等”运算符（"),t("code",[s._v("==")]),s._v("）来判断两个 "),t("code",[s._v("Vector2D")]),s._v(" 实例是否相等。对于 "),t("code",[s._v("Vector2D")]),s._v(" 来说，“相等”意味着“两个实例的 "),t("code",[s._v("x")]),s._v(" 和 "),t("code",[s._v("y")]),s._v(" 都相等”，这也是代码中用来进行判等的逻辑。如果你已经实现了“相等”运算符，通常情况下你并不需要自己再去实现“不等”运算符（"),t("code",[s._v("!=")]),s._v("）。标准库对于“不等”运算符提供了默认的实现，它简单地将“相等”运算符的结果进行取反后返回。")]),s._v(" "),t("p",[s._v("现在我们可以使用这两个运算符来判断两个 "),t("code",[s._v("Vector2D")]),s._v(" 实例是否相等：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" twoThree "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" anotherTwoThree "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" twoThree "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" anotherTwoThree "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("print")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string-literal"}},[t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"These two vectors are equivalent."')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 打印“These two vectors are equivalent.”")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("多数简单情况下，你可以让 Swift 合成等价运算符的实现，详见 "),t("RouterLink",{attrs:{to:"/pages/82f958/#使用合成实现来采纳协议"}},[s._v("使用合成实现来采纳协议")]),s._v("。")],1),s._v(" "),t("h2",{attrs:{id:"自定义运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义运算符"}},[s._v("#")]),s._v(" 自定义运算符")]),s._v(" "),t("p",[s._v("除了实现标准运算符，在 Swift 中还可以声明和实现"),t("em",[s._v("自定义运算符")]),s._v("。可以用来自定义运算符的字符列表请参考 "),t("RouterLink",{attrs:{to:"/pages/4b779c/#运算符"}},[s._v("运算符")]),s._v("。")],1),s._v(" "),t("p",[s._v("新的运算符要使用 "),t("code",[s._v("operator")]),s._v(" 关键字在全局作用域内进行定义，同时还要指定 "),t("code",[s._v("prefix")]),s._v("、"),t("code",[s._v("infix")]),s._v(" 或者 "),t("code",[s._v("postfix")]),s._v(" 修饰符：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("prefix")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("operator")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+++")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("上面的代码定义了一个新的名为 "),t("code",[s._v("+++")]),s._v(" 的前缀运算符。对于这个运算符，在 Swift 中并没有已知的意义，因此在针对 "),t("code",[s._v("Vector2D")]),s._v(" 实例的特定上下文中，给予了它自定义的意义。对这个示例来讲，"),t("code",[s._v("+++")]),s._v(" 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵与自身进行相加，从而让 "),t("code",[s._v("Vector2D")]),s._v(" 实例的 "),t("code",[s._v("x")]),s._v(" 属性和 "),t("code",[s._v("y")]),s._v(" 属性值翻倍。你可以像下面这样通过对 "),t("code",[s._v("Vector2D")]),s._v(" 添加一个 "),t("code",[s._v("+++")]),s._v(" 类方法，来实现 "),t("code",[s._v("+++")]),s._v(" 运算符：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extension")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("prefix")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+++")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("vector"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("inout")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("->")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        vector "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+=")]),s._v(" vector\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" vector\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" toBeDoubled "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" afterDoubling "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+++")]),s._v("toBeDoubled\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// toBeDoubled 现在的值为 (2.0, 8.0)")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// afterDoubling 现在的值也为 (2.0, 8.0)")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br")])]),t("h3",{attrs:{id:"自定义中缀运算符的优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义中缀运算符的优先级"}},[s._v("#")]),s._v(" 自定义中缀运算符的优先级")]),s._v(" "),t("p",[s._v("每个自定义中缀运算符都属于某个优先级组。优先级组指定了这个运算符相对于其他中缀运算符的优先级和结合性。"),t("a",{attrs:{href:"#%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7"}},[s._v("优先级和结合性")]),s._v(" 中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。")]),s._v(" "),t("p",[s._v("而没有明确放入某个优先级组的自定义中缀运算符将会被放到一个默认的优先级组内，其优先级高于三元运算符。")]),s._v(" "),t("p",[s._v("以下例子定义了一个新的自定义中缀运算符 "),t("code",[s._v("+-")]),s._v("，此运算符属于 "),t("code",[s._v("AdditionPrecedence")]),s._v(" 优先组：")]),s._v(" "),t("div",{staticClass:"language-swift line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("infix")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("operator")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+-")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("AdditionPrecedence")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extension")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("->")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("x "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("left")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("y "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" firstVector "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" secondVector "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Vector2D")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" plusMinusVector "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" firstVector "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+-")]),s._v(" secondVector\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("p",[s._v("这个运算符把两个向量的 "),t("code",[s._v("x")]),s._v(" 值相加，同时从第一个向量的 "),t("code",[s._v("y")]),s._v(" 中减去第二个向量的 "),t("code",[s._v("y")]),s._v(" 。因为它本质上是属于“相加型”运算符，所以将它放置在 "),t("code",[s._v("+")]),s._v(" 和 "),t("code",[s._v("-")]),s._v(" 等默认中缀“相加型”运算符相同的优先级组中。关于 Swift 标准库提供的运算符，以及完整的运算符优先级组和结合性设置，请参考 "),t("a",{attrs:{href:"https://developer.apple.com/documentation/swift/operator_declarations",target:"_blank",rel:"noopener noreferrer"}},[s._v("运算符声明"),t("OutboundLink")],1),s._v("。而更多关于优先级组以及自定义操作符和优先级组的语法，请参考 "),t("RouterLink",{attrs:{to:"/pages/756349/#运算符声明"}},[s._v("运算符声明")]),s._v("。")],1),s._v(" "),t("blockquote",[t("p",[s._v("注意")]),s._v(" "),t("p",[s._v("当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，如果对同一个值同时使用前缀与后缀运算符，则后缀运算符会先参与运算。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);