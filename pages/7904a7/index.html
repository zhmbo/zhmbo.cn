<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《Swift编程语言》- 闭包 | zhmbo</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/img/favicon.ico">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/MouseClickEffect.js"></script>
    <script src="/js/FooterFish.js"></script>
    <meta name="description" content="zhmbo的技术博客,专注iOS技术分享,iOS,OC,Objective-C,Swift,SwiftUI,Apple,上架,Flutter,OpenGL,Xcode,Github,RxSwift,算法,架构,面试,zhmbo,zb,ZB,zhmbo,jumbo">
    <meta name="keywords" content="zhmbo,zhmbo,zhangbao,zhmbo的技术博客,个人博客,博客搭建,专注iOS技术分享,iOS,iOS进阶,iOS高级,OC,Objective-C,Swift,SwiftUI,Apple,上架,Flutter,OpenGL,Xcode,RxSwift,UIButton,UITableView,网络请求,Github,GithubActions,算法,架构,面试,zb,ZB,zhmbo,jumbo">
    <meta name="baidu-site-verification" content="code-l7ZsTFnxp5">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.8e525da2.css" as="style"><link rel="preload" href="/assets/js/app.f91ba302.js" as="script"><link rel="preload" href="/assets/js/2.dd713b59.js" as="script"><link rel="preload" href="/assets/js/3.069de0ac.js" as="script"><link rel="preload" href="/assets/js/19.7f321d7b.js" as="script"><link rel="prefetch" href="/assets/js/10.eca7f202.js"><link rel="prefetch" href="/assets/js/100.884f2e2c.js"><link rel="prefetch" href="/assets/js/101.77e3c5d7.js"><link rel="prefetch" href="/assets/js/102.fbb46419.js"><link rel="prefetch" href="/assets/js/103.4285ab2f.js"><link rel="prefetch" href="/assets/js/104.b9d45e83.js"><link rel="prefetch" href="/assets/js/105.9af86ee7.js"><link rel="prefetch" href="/assets/js/106.f8baee69.js"><link rel="prefetch" href="/assets/js/107.fa4c186a.js"><link rel="prefetch" href="/assets/js/108.155cdba8.js"><link rel="prefetch" href="/assets/js/11.d5dc511b.js"><link rel="prefetch" href="/assets/js/12.126fd524.js"><link rel="prefetch" href="/assets/js/13.31add050.js"><link rel="prefetch" href="/assets/js/14.8f5927ce.js"><link rel="prefetch" href="/assets/js/15.5d73bb50.js"><link rel="prefetch" href="/assets/js/16.b7715387.js"><link rel="prefetch" href="/assets/js/17.b3336126.js"><link rel="prefetch" href="/assets/js/18.f0bd764d.js"><link rel="prefetch" href="/assets/js/20.8a704687.js"><link rel="prefetch" href="/assets/js/21.6c9b4fd0.js"><link rel="prefetch" href="/assets/js/22.ce92c244.js"><link rel="prefetch" href="/assets/js/23.cbae088c.js"><link rel="prefetch" href="/assets/js/24.64936988.js"><link rel="prefetch" href="/assets/js/25.6ff36218.js"><link rel="prefetch" href="/assets/js/26.192e5aa3.js"><link rel="prefetch" href="/assets/js/27.5d49847d.js"><link rel="prefetch" href="/assets/js/28.865bfa0a.js"><link rel="prefetch" href="/assets/js/29.652b637f.js"><link rel="prefetch" href="/assets/js/30.2d2405ab.js"><link rel="prefetch" href="/assets/js/31.ff15975d.js"><link rel="prefetch" href="/assets/js/32.319807cb.js"><link rel="prefetch" href="/assets/js/33.b87269c8.js"><link rel="prefetch" href="/assets/js/34.2c88022c.js"><link rel="prefetch" href="/assets/js/35.090f353e.js"><link rel="prefetch" href="/assets/js/36.ef1f9b0b.js"><link rel="prefetch" href="/assets/js/37.ba5ce128.js"><link rel="prefetch" href="/assets/js/38.3c99d047.js"><link rel="prefetch" href="/assets/js/39.20a400e2.js"><link rel="prefetch" href="/assets/js/4.39a2702d.js"><link rel="prefetch" href="/assets/js/40.0f612174.js"><link rel="prefetch" href="/assets/js/41.c39b1818.js"><link rel="prefetch" href="/assets/js/42.73cd76fc.js"><link rel="prefetch" href="/assets/js/43.fec22db6.js"><link rel="prefetch" href="/assets/js/44.24cf9514.js"><link rel="prefetch" href="/assets/js/45.1a7bd4ad.js"><link rel="prefetch" href="/assets/js/46.2772e34b.js"><link rel="prefetch" href="/assets/js/47.b4eeef41.js"><link rel="prefetch" href="/assets/js/48.6e849ea1.js"><link rel="prefetch" href="/assets/js/49.e0c5a13d.js"><link rel="prefetch" href="/assets/js/5.5d94312a.js"><link rel="prefetch" href="/assets/js/50.773364d5.js"><link rel="prefetch" href="/assets/js/51.1db99b25.js"><link rel="prefetch" href="/assets/js/52.8c4dc63b.js"><link rel="prefetch" href="/assets/js/53.ebf1abab.js"><link rel="prefetch" href="/assets/js/54.016f21d7.js"><link rel="prefetch" href="/assets/js/55.73199a2d.js"><link rel="prefetch" href="/assets/js/56.3316e67d.js"><link rel="prefetch" href="/assets/js/57.57c6a9d7.js"><link rel="prefetch" href="/assets/js/58.65589959.js"><link rel="prefetch" href="/assets/js/59.abcabc64.js"><link rel="prefetch" href="/assets/js/6.8a416018.js"><link rel="prefetch" href="/assets/js/60.d382d1c3.js"><link rel="prefetch" href="/assets/js/61.c76620c7.js"><link rel="prefetch" href="/assets/js/62.44f03a5b.js"><link rel="prefetch" href="/assets/js/63.92fa470c.js"><link rel="prefetch" href="/assets/js/64.2475bc0a.js"><link rel="prefetch" href="/assets/js/65.e33c22e2.js"><link rel="prefetch" href="/assets/js/66.b213e189.js"><link rel="prefetch" href="/assets/js/67.54079f5f.js"><link rel="prefetch" href="/assets/js/68.9490fd8d.js"><link rel="prefetch" href="/assets/js/69.c9253eff.js"><link rel="prefetch" href="/assets/js/7.369ac24e.js"><link rel="prefetch" href="/assets/js/70.1c59f92a.js"><link rel="prefetch" href="/assets/js/71.3492471a.js"><link rel="prefetch" href="/assets/js/72.cec16c5f.js"><link rel="prefetch" href="/assets/js/73.50e8862b.js"><link rel="prefetch" href="/assets/js/74.086f16c5.js"><link rel="prefetch" href="/assets/js/75.5554210f.js"><link rel="prefetch" href="/assets/js/76.dfb35acc.js"><link rel="prefetch" href="/assets/js/77.440dde49.js"><link rel="prefetch" href="/assets/js/78.22d12fc4.js"><link rel="prefetch" href="/assets/js/79.7805a9b0.js"><link rel="prefetch" href="/assets/js/8.dd8ea451.js"><link rel="prefetch" href="/assets/js/80.0f6e99d9.js"><link rel="prefetch" href="/assets/js/81.775865b4.js"><link rel="prefetch" href="/assets/js/82.b0a6a6bc.js"><link rel="prefetch" href="/assets/js/83.b4431f89.js"><link rel="prefetch" href="/assets/js/84.9266dd31.js"><link rel="prefetch" href="/assets/js/85.6250c179.js"><link rel="prefetch" href="/assets/js/86.8def8d74.js"><link rel="prefetch" href="/assets/js/87.ae604169.js"><link rel="prefetch" href="/assets/js/88.ea0b4861.js"><link rel="prefetch" href="/assets/js/89.86dbd55a.js"><link rel="prefetch" href="/assets/js/9.d1ab447d.js"><link rel="prefetch" href="/assets/js/90.9225e7d0.js"><link rel="prefetch" href="/assets/js/91.f6bbf533.js"><link rel="prefetch" href="/assets/js/92.a7f31cba.js"><link rel="prefetch" href="/assets/js/93.540860df.js"><link rel="prefetch" href="/assets/js/94.2e3d73ab.js"><link rel="prefetch" href="/assets/js/95.e35292b9.js"><link rel="prefetch" href="/assets/js/96.c8174b05.js"><link rel="prefetch" href="/assets/js/97.f7b36c87.js"><link rel="prefetch" href="/assets/js/98.555706b2.js"><link rel="prefetch" href="/assets/js/99.70b5aa9a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8e525da2.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div class="width-limit"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link"><img src="https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/202407311741918.png" alt="zhmbo" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont jumbo-nav-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="iOS" class="dropdown-title"><a href="/ios/" class="link-title"><i class="iconfont jumbo-apple"></i>
      iOS
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-apple"></i>
      iOS
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>iOS开发精髓</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/3f0170/" class="nav-link"><i class="iconfont undefined"></i>
  介绍
</a></li><li class="dropdown-subitem"><a href="/pages/7354af/" class="nav-link"><i class="iconfont undefined"></i>
  从入门
</a></li><li class="dropdown-subitem"><a href="/pages/1b29d1/" class="nav-link"><i class="iconfont undefined"></i>
  到放弃
</a></li></ul></li><li class="dropdown-item"><h4>iOS充电宝</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/5cb5f0/" class="nav-link"><i class="iconfont undefined"></i>
  SwiftUI
</a></li><li class="dropdown-subitem"><a href="/pages/9e761f/" class="nav-link"><i class="iconfont undefined"></i>
  iOS14
</a></li><li class="dropdown-subitem"><a href="/pages/5e2170/" class="nav-link"><i class="iconfont undefined"></i>
  Xcode12
</a></li><li class="dropdown-subitem"><a href="/pages/554b82/" class="nav-link"><i class="iconfont undefined"></i>
  iOS周边
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Swift" class="dropdown-title"><a href="/swift/" class="link-title"><i class="iconfont jumbo-swift"></i>
      Swift
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-swift"></i>
      Swift
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/04ed05/" class="nav-link"><i class="iconfont undefined"></i>
  概览
</a></li><li class="dropdown-item"><!----> <a href="/pages/cf2b9a/" class="nav-link"><i class="iconfont undefined"></i>
  欢迎来到Swift
</a></li><li class="dropdown-item"><!----> <a href="/pages/9e2f81/" class="nav-link"><i class="iconfont undefined"></i>
  Swift语法
</a></li><li class="dropdown-item"><!----> <a href="/pages/581348/" class="nav-link"><i class="iconfont undefined"></i>
  语言参考
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title"><i class="iconfont jumbo-jishu"></i>
      技术
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-jishu"></i>
      技术
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/4f2c93/" class="nav-link"><i class="iconfont undefined"></i>
  博客
</a></li><li class="dropdown-item"><!----> <a href="/pages/6cbba7/" class="nav-link"><i class="iconfont undefined"></i>
  Github
</a></li><li class="dropdown-item"><!----> <a href="/pages/d9a627/" class="nav-link"><i class="iconfont undefined"></i>
  CocosCreator
</a></li><li class="dropdown-item"><!----> <a href="/pages/9af5e1/" class="nav-link"><i class="iconfont undefined"></i>
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/pages/46944a/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/pages/4b617e/" class="nav-link"><i class="iconfont undefined"></i>
  Android
</a></li><li class="dropdown-item"><!----> <a href="/pages/6ee1a4/" class="nav-link"><i class="iconfont undefined"></i>
  Git
</a></li></ul></div></div><div class="nav-item"><a href="/leaveword/" class="nav-link"><i class="iconfont jumbo-liuyan"></i>
  留言
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title"><i class="iconfont jumbo-suoyin"></i>
      索引
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-suoyin"></i>
      索引
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link"><i class="iconfont undefined"></i>
  分类
</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link"><i class="iconfont undefined"></i>
  标签
</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link"><i class="iconfont undefined"></i>
  归档
</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link"><i class="iconfont undefined"></i>
  友链
</a></li><li class="dropdown-item"><!----> <a href="/navigation/" class="nav-link"><i class="iconfont undefined"></i>
  导航
</a></li><li class="dropdown-item"><!----> <a href="/findme/" class="nav-link"><i class="iconfont undefined"></i>
  寻Me
</a></li></ul></div></div> <!----></nav></div></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20200919111632.png"> <div class="blogger-info"><h3>@jumbo</h3> <span>an ios developer</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont jumbo-nav-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="iOS" class="dropdown-title"><a href="/ios/" class="link-title"><i class="iconfont jumbo-apple"></i>
      iOS
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-apple"></i>
      iOS
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>iOS开发精髓</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/3f0170/" class="nav-link"><i class="iconfont undefined"></i>
  介绍
</a></li><li class="dropdown-subitem"><a href="/pages/7354af/" class="nav-link"><i class="iconfont undefined"></i>
  从入门
</a></li><li class="dropdown-subitem"><a href="/pages/1b29d1/" class="nav-link"><i class="iconfont undefined"></i>
  到放弃
</a></li></ul></li><li class="dropdown-item"><h4>iOS充电宝</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/5cb5f0/" class="nav-link"><i class="iconfont undefined"></i>
  SwiftUI
</a></li><li class="dropdown-subitem"><a href="/pages/9e761f/" class="nav-link"><i class="iconfont undefined"></i>
  iOS14
</a></li><li class="dropdown-subitem"><a href="/pages/5e2170/" class="nav-link"><i class="iconfont undefined"></i>
  Xcode12
</a></li><li class="dropdown-subitem"><a href="/pages/554b82/" class="nav-link"><i class="iconfont undefined"></i>
  iOS周边
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Swift" class="dropdown-title"><a href="/swift/" class="link-title"><i class="iconfont jumbo-swift"></i>
      Swift
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-swift"></i>
      Swift
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/04ed05/" class="nav-link"><i class="iconfont undefined"></i>
  概览
</a></li><li class="dropdown-item"><!----> <a href="/pages/cf2b9a/" class="nav-link"><i class="iconfont undefined"></i>
  欢迎来到Swift
</a></li><li class="dropdown-item"><!----> <a href="/pages/9e2f81/" class="nav-link"><i class="iconfont undefined"></i>
  Swift语法
</a></li><li class="dropdown-item"><!----> <a href="/pages/581348/" class="nav-link"><i class="iconfont undefined"></i>
  语言参考
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title"><i class="iconfont jumbo-jishu"></i>
      技术
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-jishu"></i>
      技术
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/4f2c93/" class="nav-link"><i class="iconfont undefined"></i>
  博客
</a></li><li class="dropdown-item"><!----> <a href="/pages/6cbba7/" class="nav-link"><i class="iconfont undefined"></i>
  Github
</a></li><li class="dropdown-item"><!----> <a href="/pages/d9a627/" class="nav-link"><i class="iconfont undefined"></i>
  CocosCreator
</a></li><li class="dropdown-item"><!----> <a href="/pages/9af5e1/" class="nav-link"><i class="iconfont undefined"></i>
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/pages/46944a/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/pages/4b617e/" class="nav-link"><i class="iconfont undefined"></i>
  Android
</a></li><li class="dropdown-item"><!----> <a href="/pages/6ee1a4/" class="nav-link"><i class="iconfont undefined"></i>
  Git
</a></li></ul></div></div><div class="nav-item"><a href="/leaveword/" class="nav-link"><i class="iconfont jumbo-liuyan"></i>
  留言
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title"><i class="iconfont jumbo-suoyin"></i>
      索引
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-suoyin"></i>
      索引
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link"><i class="iconfont undefined"></i>
  分类
</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link"><i class="iconfont undefined"></i>
  标签
</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link"><i class="iconfont undefined"></i>
  归档
</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link"><i class="iconfont undefined"></i>
  友链
</a></li><li class="dropdown-item"><!----> <a href="/navigation/" class="nav-link"><i class="iconfont undefined"></i>
  导航
</a></li><li class="dropdown-item"><!----> <a href="/findme/" class="nav-link"><i class="iconfont undefined"></i>
  寻Me
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/pages/04ed05/" class="sidebar-link">概览</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>欢迎来到Swift</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Swift语法</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9e2f81/" class="sidebar-link">基础知识</a></li><li><a href="/pages/279dd7/" class="sidebar-link">基本运算符</a></li><li><a href="/pages/2850e8/" class="sidebar-link">字符串和字符</a></li><li><a href="/pages/4b4c78/" class="sidebar-link">集合类型</a></li><li><a href="/pages/544cb0/" class="sidebar-link">控制流</a></li><li><a href="/pages/b69d99/" class="sidebar-link">函数</a></li><li><a href="/pages/7904a7/" aria-current="page" class="active sidebar-link">闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/7904a7/#闭包表达式" class="sidebar-link">闭包表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/7904a7/#排序方法" class="sidebar-link">排序方法</a></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#闭包表达式语法" class="sidebar-link">闭包表达式语法</a></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#根据上下文推断类型" class="sidebar-link">根据上下文推断类型</a></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#单表达式闭包的隐式返回" class="sidebar-link">单表达式闭包的隐式返回</a></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#参数名称缩写" class="sidebar-link">参数名称缩写</a></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#运算符方法" class="sidebar-link">运算符方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#尾随闭包" class="sidebar-link">尾随闭包</a></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#值捕获" class="sidebar-link">值捕获</a></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#闭包是引用类型" class="sidebar-link">闭包是引用类型</a></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#逃逸闭包" class="sidebar-link">逃逸闭包</a></li><li class="sidebar-sub-header"><a href="/pages/7904a7/#自动闭包" class="sidebar-link">自动闭包</a></li></ul></li><li><a href="/pages/56276f/" class="sidebar-link">枚举</a></li><li><a href="/pages/0641bb/" class="sidebar-link">类和结构体</a></li><li><a href="/pages/ce0459/" class="sidebar-link">属性</a></li><li><a href="/pages/efc653/" class="sidebar-link">方法</a></li><li><a href="/pages/e35887/" class="sidebar-link">下标</a></li><li><a href="/pages/09b0f4/" class="sidebar-link">继承</a></li><li><a href="/pages/1b072a/" class="sidebar-link">构造过程</a></li><li><a href="/pages/c40911/" class="sidebar-link">解析过程</a></li><li><a href="/pages/96b368/" class="sidebar-link">可选链</a></li><li><a href="/pages/cc5b2d/" class="sidebar-link">错误处理</a></li><li><a href="/pages/757c02/" class="sidebar-link">类型转换</a></li><li><a href="/pages/1d43f5/" class="sidebar-link">嵌套类型</a></li><li><a href="/pages/297d1c/" class="sidebar-link">扩展</a></li><li><a href="/pages/82f958/" class="sidebar-link">协议</a></li><li><a href="/pages/0d8a5e/" class="sidebar-link">泛型</a></li><li><a href="/pages/46ff18/" class="sidebar-link">不透明类型</a></li><li><a href="/pages/51a2dd/" class="sidebar-link">自动引用计数</a></li><li><a href="/pages/9224f8/" class="sidebar-link">内存安全</a></li><li><a href="/pages/6c25a0/" class="sidebar-link">访问控制</a></li><li><a href="/pages/9854b9/" class="sidebar-link">高级运算符</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>语言参考</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"> <div class="theme-vdoing-wrapper bg-style-1"><div class="articleInfo-wrap" data-v-7e90c5a4><div class="articleInfo" data-v-7e90c5a4><ul class="breadcrumbs" data-v-7e90c5a4><li data-v-7e90c5a4><a href="/" title="首页" class="iconfont jumbo-home router-link-active" data-v-7e90c5a4></a></li> <li data-v-7e90c5a4><a href="/categories/?category=Swift%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80" title="分类" data-v-7e90c5a4>Swift编程语言</a></li> <li data-v-7e90c5a4><a href="/categories/?category=Swift%E8%AF%AD%E6%B3%95" title="分类" data-v-7e90c5a4>Swift语法</a></li></ul> <div class="info" data-v-7e90c5a4><div title="作者" class="author iconfont jumbo-author" data-v-7e90c5a4><a href="https://github.com/zhmbo" target="_blank" title="作者" class="beLink" data-v-7e90c5a4>zhmbo</a></div> <div title="创建时间" class="date iconfont jumbo-time" data-v-7e90c5a4><a href="javascript:;" data-v-7e90c5a4>2020-11-10</a></div> <div title="统计" class="date iconfont jumbo-eye" data-v-7e90c5a4><span id="/pages/7904a7/" data-flag-title="《Swift编程语言》- 闭包" class="leancloud-visitors" data-v-7e90c5a4><a class="leancloud-visitors-count" style="font-size:.7rem;font-weight:normal;color:#999;"></a></span></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">
          《Swift编程语言》- 闭包
        </h1> <div class="theme-vdoing-content content__default"><p><em>闭包</em>是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的匿名函数（Lambdas）比较相似。</p> <p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为<em>包裹</em>常量和变量。 Swift 会为你管理在捕获过程中涉及到的所有内存操作。</p> <blockquote><p>注意</p> <p>如果你不熟悉捕获（capturing）这个概念也不用担心，在 <a href="#%E5%80%BC%E6%8D%95%E8%8E%B7">值捕获</a> 章节有它更详细的介绍。</p></blockquote> <p>在 <a href="/pages/b69d99/">函数</a> 章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采用如下三种形式之一：</p> <ul><li>全局函数是一个有名字但不会捕获任何值的闭包</li> <li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li> <li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li></ul> <p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p> <ul><li>利用上下文推断参数和返回值类型</li> <li>隐式返回单表达式闭包，即单表达式闭包可以省略 <code>return</code> 关键字</li> <li>参数名称缩写</li> <li>尾随闭包语法</li></ul> <h2 id="闭包表达式"><a href="#闭包表达式" class="header-anchor">#</a> 闭包表达式</h2> <p><a href="/pages/b69d99/#嵌套函数">嵌套函数</a> 作为复杂函数的一部分时，它自包含代码块式的定义和命名形式在使用上带来了方便。当然，编写未完整声明和没有函数名的类函数结构代码是很有用的，尤其是在编码中涉及到函数作为参数的那些方法时。</p> <p><em>闭包表达式</em>是一种构建内联闭包的方式，它的语法简洁。在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式。下面通过对 <code>sorted(by:)</code> 这一个案例的多次迭代改进来展示这个过程，每次迭代都使用了更加简明的方式描述了相同功能。。</p> <h3 id="排序方法"><a href="#排序方法" class="header-anchor">#</a> 排序方法</h3> <p>Swift 标准库提供了名为 <code>sorted(by:)</code> 的方法，它会基于你提供的排序闭包表达式的判断结果对数组中的值（类型确定）进行排序。一旦它完成排序过程，<code>sorted(by:)</code> 方法会返回一个与旧数组类型大小相同类型的新数组，该数组的元素有着正确的排序顺序。原数组不会被 <code>sorted(by:)</code> 方法修改。</p> <p>下面的闭包表达式示例使用 <code>sorted(by:)</code> 方法对一个 <code>String</code> 类型的数组进行字母逆序排序。以下是初始数组：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Chris&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Alex&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Ewa&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Barry&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Daniella&quot;</span></span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>sorted(by:)</code> 方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值<em>前面</em>，排序闭包函数需要返回 <code>true</code>，反之返回 <code>false</code>。</p> <p>该例子对一个 <code>String</code> 类型的数组进行排序，因此排序闭包函数类型需为 <code>(String, String) -&gt; Bool</code>。</p> <p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为 <code>sorted(by:)</code> 方法的参数传入：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">backward</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> s1<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> s2<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s1 <span class="token operator">&gt;</span> s2
<span class="token punctuation">}</span>
<span class="token keyword">var</span> reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> backward<span class="token punctuation">)</span>
<span class="token comment">// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果第一个字符串（<code>s1</code>）大于第二个字符串（<code>s2</code>），<code>backward(_:_:)</code> 函数会返回 <code>true</code>，表示在新的数组中 <code>s1</code> 应该出现在 <code>s2</code> 前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母 <code>&quot;B&quot;</code> 大于字母 <code>&quot;A&quot;</code> ，字符串 <code>&quot;Tom&quot;</code> 大于字符串 <code>&quot;Tim&quot;</code>。该闭包将进行字母逆序排序，<code>&quot;Barry&quot;</code> 将会排在 <code>&quot;Alex&quot;</code> 之前。</p> <p>然而，以这种方式来编写一个实际上很简单的表达式（<code>a &gt; b</code>)，确实太过繁琐了。对于这个例子来说，利用闭包表达式语法可以更好地构造一个内联排序闭包。</p> <h3 id="闭包表达式语法"><a href="#闭包表达式语法" class="header-anchor">#</a> 闭包表达式语法</h3> <p>闭包表达式语法有如下的一般形式：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token punctuation">{</span> <span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">return</span> type <span class="token keyword">in</span>
    statements
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><em>闭包表达式参数</em> 可以是 in-out 参数，但不能设定默认值。如果你命名了可变参数，也可以使用此可变参数。元组也可以作为参数和返回值。</p> <p>下面的例子展示了之前 <code>backward(_:_:)</code> 函数对应的闭包表达式版本的代码：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>s1<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> s2<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token keyword">in</span>
    <span class="token keyword">return</span> s1 <span class="token operator">&gt;</span> s2
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>需要注意的是内联闭包参数和返回值类型声明与 <code>backward(_:_:)</code> 函数类型声明相同。在这两种方式中，都写成了 <code>(s1: String, s2: String) -&gt; Bool</code>。然而在内联闭包表达式中，函数和返回值类型都写在<em>大括号内</em>，而不是大括号外。</p> <p>闭包的函数体部分由关键字 <code>in</code> 引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p> <p>由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>s1<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> s2<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token keyword">in</span> <span class="token keyword">return</span> s1 <span class="token operator">&gt;</span> s2 <span class="token punctuation">}</span> <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>该例中 <code>sorted(by:)</code> 方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。</p> <h3 id="根据上下文推断类型"><a href="#根据上下文推断类型" class="header-anchor">#</a> 根据上下文推断类型</h3> <p>因为排序闭包函数是作为 <code>sorted(by:)</code> 方法的参数传入的，Swift 可以推断其参数和返回值的类型。<code>sorted(by:)</code> 方法被一个字符串数组调用，因此其参数必须是 <code>(String, String) -&gt; Bool</code> 类型的函数。这意味着 <code>(String, String)</code> 和 <code>Bool</code> 类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头（<code>-&gt;</code>）和围绕在参数周围的括号也可以被省略：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> <span class="token punctuation">{</span> s1<span class="token punctuation">,</span> s2 <span class="token keyword">in</span> <span class="token keyword">return</span> s1 <span class="token operator">&gt;</span> s2 <span class="token punctuation">}</span> <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>实际上，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，你几乎不需要利用完整格式构造内联闭包。</p> <p>尽管如此，你仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则我们更鼓励采用完整格式的闭包。而在 <code>sorted(by:)</code> 方法这个例子里，显然闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。</p> <h3 id="单表达式闭包的隐式返回"><a href="#单表达式闭包的隐式返回" class="header-anchor">#</a> 单表达式闭包的隐式返回</h3> <p>单行表达式闭包可以通过省略 <code>return</code> 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> <span class="token punctuation">{</span> s1<span class="token punctuation">,</span> s2 <span class="token keyword">in</span> s1 <span class="token operator">&gt;</span> s2 <span class="token punctuation">}</span> <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这个例子中，<code>sorted(by:)</code> 方法的参数类型明确了闭包必须返回一个 <code>Bool</code> 类型值。因为闭包函数体只包含了一个单一表达式（<code>s1 &gt; s2</code>），该表达式返回 <code>Bool</code> 类型值，因此这里没有歧义，<code>return</code> 关键字可以省略。</p> <h3 id="参数名称缩写"><a href="#参数名称缩写" class="header-anchor">#</a> 参数名称缩写</h3> <p>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 <code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数，以此类推。</p> <p>如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code> 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&gt;</span> <span class="token short-argument">$1</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这个例子中，<code>$0</code> 和 <code>$1</code> 表示闭包中第一个和第二个 <code>String</code> 类型的参数。</p> <h3 id="运算符方法"><a href="#运算符方法" class="header-anchor">#</a> 运算符方法</h3> <p>实际上还有一种更<em>简短的</em>方式来编写上面例子中的闭包表达式。Swift 的 <code>String</code> 类型定义了关于大于号（<code>&gt;</code>）的字符串实现，其作为一个函数接受两个 <code>String</code> 类型的参数并返回 <code>Bool</code> 类型的值。而这正好与 <code>sorted(by:)</code> 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断找到系统自带的那个字符串函数的实现：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> <span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>更多关于运算符方法的内容请查看 <a href="/pages/9854b9/">高级运算符</a>。</p> <h2 id="尾随闭包"><a href="#尾随闭包" class="header-anchor">#</a> 尾随闭包</h2> <p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">someFunctionThatTakesAClosure</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数体部分</span>
<span class="token punctuation">}</span>


<span class="token comment">// 以下是不使用尾随闭包进行函数调用</span>
<span class="token function">someFunctionThatTakesAClosure</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 闭包主体部分</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>


<span class="token comment">// 以下是使用尾随闭包进行函数调用</span>
<span class="token function">someFunctionThatTakesAClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 闭包主体部分</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在 <a href="#%E9%97%AD%E5%8C%85%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95">闭包表达式语法</a> 上章节中的字符串排序闭包可以作为尾随包的形式改写在 <code>sorted(by:)</code> 方法圆括号的外面：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&gt;</span> <span class="token short-argument">$1</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 <code>()</code> 省略掉：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span>sorted <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&gt;</span> <span class="token short-argument">$1</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。举例来说，Swift 的 <code>Array</code> 类型有一个 <code>map(_:)</code> 方法，这个方法获取一个闭包表达式作为其唯一参数。该闭包函数会为数组中的每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。</p> <p>当提供给数组的闭包应用于每个数组元素后，<code>map(_:)</code> 方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。</p> <p>下例介绍了如何在 <code>map(_:)</code> 方法中使用尾随闭包将 <code>Int</code> 类型数组 <code>[16, 58, 510]</code> 转换为包含对应 <code>String</code> 类型的值的数组 <code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code>：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> digitNames <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token number">0</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Zero&quot;</span></span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;One&quot;</span></span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Two&quot;</span></span><span class="token punctuation">,</span>   <span class="token number">3</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Three&quot;</span></span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Four&quot;</span></span><span class="token punctuation">,</span>
    <span class="token number">5</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Five&quot;</span></span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Six&quot;</span></span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Seven&quot;</span></span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Eight&quot;</span></span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Nine&quot;</span></span>
<span class="token punctuation">]</span>
<span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">,</span> <span class="token number">510</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如上代码创建了一个整型数位和它们英文版本名字相映射的字典。同时还定义了一个准备转换为字符串数组的整型数组。</p> <p>你现在可以通过传递一个尾随闭包给 <code>numbers</code> 数组的 <code>map(_:)</code> 方法来创建对应的字符串版本数组：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> strings <span class="token operator">=</span> numbers<span class="token punctuation">.</span>map <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token keyword">in</span>
    <span class="token keyword">var</span> number <span class="token operator">=</span> number
    <span class="token keyword">var</span> output <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span>
    <span class="token keyword">repeat</span> <span class="token punctuation">{</span>
        output <span class="token operator">=</span> digitNames<span class="token punctuation">[</span>number <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">!</span> <span class="token operator">+</span> output
        number <span class="token operator">/=</span> <span class="token number">10</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> number <span class="token operator">&gt;</span> <span class="token number">0</span>
    <span class="token keyword">return</span> output
<span class="token punctuation">}</span>
<span class="token comment">// strings 常量被推断为字符串类型数组，即 [String]</span>
<span class="token comment">// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><code>map(_:)</code> 为数组中每一个元素调用了一次闭包表达式。你不需要指定闭包的输入参数 <code>number</code> 的类型，因为可以通过要映射的数组类型进行推断。</p> <p>在该例中，局部变量 <code>number</code> 的值由闭包中的 <code>number</code> 参数获得，因此可以在闭包函数体内对其进行修改，(闭包或者函数的参数总是常量)，闭包表达式指定了返回类型为 <code>String</code>，以表明存储映射值的新数组类型为 <code>String</code>。</p> <p>闭包表达式在每次被调用的时候创建了一个叫做 <code>output</code> 的字符串并返回。其使用求余运算符（<code>number % 10</code>）计算最后一位数字并利用 <code>digitNames</code> 字典获取所映射的字符串。这个闭包能够用于创建任意正整数的字符串表示。</p> <blockquote><p>注意</p> <p>字典 <code>digitNames</code> 下标后跟着一个叹号（<code>!</code>），因为字典下标返回一个可选值（optional value），表明该键不存在时会查找失败。在上例中，由于可以确定 <code>number % 10</code> 总是 <code>digitNames</code> 字典的有效下标，因此叹号可以用于强制解包（force-unwrap）存储在下标的可选类型的返回值中的 <code>String</code> 类型的值。</p></blockquote> <p>从 <code>digitNames</code> 字典中获取的字符串被添加到 <code>output</code> 的<em>前部</em>，逆序建立了一个字符串版本的数字。（在表达式 <code>number % 10</code> 中，如果 <code>number</code> 为 <code>16</code>，则返回 <code>6</code>，<code>58</code> 返回 <code>8</code>，<code>510</code> 返回 <code>0</code>。）</p> <p><code>number</code> 变量之后除以 <code>10</code>。因为其是整数，在计算过程中未除尽部分被忽略。因此 <code>16</code> 变成了 <code>1</code>，<code>58</code> 变成了 <code>5</code>，<code>510</code> 变成了 <code>51</code>。</p> <p>整个过程重复进行，直到 <code>number /= 10</code> 为 <code>0</code>，这时闭包会将字符串 <code>output</code> 返回，而 <code>map(_:)</code> 方法则会将字符串添加到映射数组中。</p> <p>在上面的例子中，通过尾随闭包语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在 <code>map(_:)</code> 方法的括号内。</p> <h2 id="值捕获"><a href="#值捕获" class="header-anchor">#</a> 值捕获</h2> <p>闭包可以在其被定义的上下文中<em>捕获</em>常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p> <p>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p> <p>举个例子，这有一个叫做 <code>makeIncrementer</code> 的函数，其包含了一个叫做 <code>incrementer</code> 的嵌套函数。嵌套函数 <code>incrementer()</code> 从上下文中捕获了两个值，<code>runningTotal</code> 和 <code>amount</code>。捕获这些值之后，<code>makeIncrementer</code> 将 <code>incrementer</code> 作为闭包返回。每次调用 <code>incrementer</code> 时，其会以 <code>amount</code> 作为增量增加 <code>runningTotal</code> 的值。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">makeIncrementer</span><span class="token punctuation">(</span>forIncrement amount<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> runningTotal <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">func</span> <span class="token function-definition function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        runningTotal <span class="token operator">+=</span> amount
        <span class="token keyword">return</span> runningTotal
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> incrementer
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>makeIncrementer</code> 返回类型为 <code>() -&gt; Int</code>。这意味着其返回的是一个<em>函数</em>，而非一个简单类型的值。该函数在每次调用时不接受参数，只返回一个 <code>Int</code> 类型的值。关于函数返回其他函数的内容，请查看 <a href="/pages/b69d99/#函数类型作为返回类型">函数类型作为返回类型</a>。</p> <p><code>makeIncrementer(forIncrement:)</code> 函数定义了一个初始值为 <code>0</code> 的整型变量 <code>runningTotal</code>，用来存储当前总计数值。该值为 <code>incrementer</code> 的返回值。</p> <p><code>makeIncrementer(forIncrement:)</code> 有一个 <code>Int</code> 类型的参数，其外部参数名为 <code>forIncrement</code>，内部参数名为 <code>amount</code>，该参数表示每次 <code>incrementer</code> 被调用时 <code>runningTotal</code> 将要增加的量。<code>makeIncrementer</code> 函数还定义了一个嵌套函数 <code>incrementer</code>，用来执行实际的增加操作。该函数简单地使 <code>runningTotal</code> 增加 <code>amount</code>，并将其返回。</p> <p>如果我们单独考虑嵌套函数 <code>incrementer()</code>，会发现它有些不同寻常：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    runningTotal <span class="token operator">+=</span> amount
    <span class="token keyword">return</span> runningTotal
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>incrementer()</code> 函数并没有任何参数，但是在函数体内访问了 <code>runningTotal</code> 和 <code>amount</code> 变量。这是因为它从外围函数捕获了 <code>runningTotal</code> 和 <code>amount</code> 变量的<em>引用</em>。捕获引用保证了 <code>runningTotal</code> 和 <code>amount</code> 变量在调用完 <code>makeIncrementer</code> 后不会消失，并且保证了在下一次执行 <code>incrementer</code> 函数时，<code>runningTotal</code> 依旧存在。</p> <blockquote><p>注意</p> <p>为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。</p> <p>Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p></blockquote> <p>下面是一个使用 <code>makeIncrementer</code> 的例子：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> incrementByTen <span class="token operator">=</span> <span class="token function">makeIncrementer</span><span class="token punctuation">(</span>forIncrement<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>该例子定义了一个叫做 <code>incrementByTen</code> 的常量，该常量指向一个每次调用会将其 <code>runningTotal</code> 变量增加 <code>10</code> 的 <code>incrementer</code> 函数。调用这个函数多次可以得到以下结果：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token function">incrementByTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 返回的值为10</span>
<span class="token function">incrementByTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 返回的值为20</span>
<span class="token function">incrementByTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 返回的值为30</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果你创建了另一个 <code>incrementer</code>，它会有属于自己的引用，指向一个全新、独立的 <code>runningTotal</code> 变量：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> incrementBySeven <span class="token operator">=</span> <span class="token function">makeIncrementer</span><span class="token punctuation">(</span>forIncrement<span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">)</span>
<span class="token function">incrementBySeven</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 返回的值为7</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>再次调用原来的 <code>incrementByTen</code> 会继续增加它自己的 <code>runningTotal</code> 变量，该变量和 <code>incrementBySeven</code> 中捕获的变量没有任何联系：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token function">incrementByTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 返回的值为40</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>注意</p> <p>如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用。更多信息，请参考 <a href="/pages/51a2dd/#闭包的循环强引用">闭包的循环强引用</a>。</p></blockquote> <h2 id="闭包是引用类型"><a href="#闭包是引用类型" class="header-anchor">#</a> 闭包是引用类型</h2> <p>上面的例子中，<code>incrementBySeven</code> 和 <code>incrementByTen</code> 都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是<em>引用类型</em>。</p> <p>无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的<em>引用</em>。上面的例子中，指向闭包的引用 <code>incrementByTen</code> 是一个常量，而并非闭包内容本身。</p> <p>这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> alsoIncrementByTen <span class="token operator">=</span> incrementByTen
<span class="token function">alsoIncrementByTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 返回的值为50</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="逃逸闭包"><a href="#逃逸闭包" class="header-anchor">#</a> 逃逸闭包</h2> <p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中<em>逃逸</em>。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 <code>@escaping</code>，用来指明这个闭包是允许“逃逸”出这个函数的。</p> <p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">var</span> completionHandlers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">func</span> <span class="token function-definition function">someFunctionWithEscapingClosure</span><span class="token punctuation">(</span>completionHandler<span class="token punctuation">:</span> <span class="token attribute atrule">@escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    completionHandlers<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>completionHandler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>someFunctionWithEscapingClosure(_:)</code> 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你不将这个参数标记为 <code>@escaping</code>，就会得到一个编译错误。</p> <p>将一个闭包标记为 <code>@escaping</code> 意味着你必须在闭包中显式地引用 <code>self</code>。比如说，在下面的代码中，传递到 <code>someFunctionWithEscapingClosure(_:)</code> 中的闭包是一个逃逸闭包，这意味着它需要显式地引用 <code>self</code>。相对的，传递到 <code>someFunctionWithNonescapingClosure(_:)</code> 中的闭包是一个非逃逸闭包，这意味着它可以隐式引用 <code>self</code>。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">func</span> <span class="token function-definition function">someFunctionWithNonescapingClosure</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span>
    <span class="token keyword">func</span> <span class="token function-definition function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        someFunctionWithEscapingClosure <span class="token punctuation">{</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">}</span>
        someFunctionWithNonescapingClosure <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">200</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token class-name">SomeClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
instance<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
<span class="token comment">// 打印出“200”</span>


completionHandlers<span class="token punctuation">.</span>first<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
<span class="token comment">// 打印出“100”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="自动闭包"><a href="#自动闭包" class="header-anchor">#</a> 自动闭包</h2> <p><em>自动闭包</em>是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。</p> <p>我们经常会<em>调用</em>采用自动闭包的函数，但是很少去<em>实现</em>这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code> 函数接受自动闭包作为它的 <code>condition</code> 参数和 <code>message</code> 参数；它的 <code>condition</code> 参数仅会在 debug 模式下被求值，它的 <code>message</code> 参数仅当 <code>condition</code> 参数为 <code>false</code> 时被计算求值。</p> <p>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。下面的代码展示了闭包如何延时求值。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">var</span> customersInLine <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Chris&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Alex&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Ewa&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Barry&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;Daniella&quot;</span></span><span class="token punctuation">]</span>
<span class="token function">print</span><span class="token punctuation">(</span>customersInLine<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
<span class="token comment">// 打印出“5”</span>


<span class="token keyword">let</span> customerProvider <span class="token operator">=</span> <span class="token punctuation">{</span> customersInLine<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span>customersInLine<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
<span class="token comment">// 打印出“5”</span>


<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Now serving </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token function">customerProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// 打印出“Now serving Chris!”</span>
<span class="token function">print</span><span class="token punctuation">(</span>customersInLine<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
<span class="token comment">// 打印出“4”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>尽管在闭包的代码中，<code>customersInLine</code> 的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，<code>customerProvider</code> 的类型不是 <code>String</code>，而是 <code>() -&gt; String</code>，一个没有参数且返回值为 <code>String</code> 的函数。</p> <p>将闭包作为参数传递给函数时，你能获得同样的延时求值行为。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token comment">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span>
<span class="token keyword">func</span> <span class="token function-definition function">serve</span><span class="token punctuation">(</span>customer customerProvider<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Now serving </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token function">customerProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">serve</span><span class="token punctuation">(</span>customer<span class="token punctuation">:</span> <span class="token punctuation">{</span> customersInLine<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token comment">// 打印出“Now serving Alex!”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面的 <code>serve(customer:)</code> 函数接受一个返回顾客名字的显式的闭包。下面这个版本的 <code>serve(customer:)</code> 完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 <code>@autoclosure</code> 来接收一个自动闭包。现在你可以将该函数当作接受 <code>String</code> 类型参数（而非闭包）的函数来调用。<code>customerProvider</code> 参数将自动转化为一个闭包，因为该参数被标记了 <code>@autoclosure</code> 特性。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span>
<span class="token keyword">func</span> <span class="token function-definition function">serve</span><span class="token punctuation">(</span>customer customerProvider<span class="token punctuation">:</span> <span class="token attribute atrule">@autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Now serving </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token function">customerProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">serve</span><span class="token punctuation">(</span>customer<span class="token punctuation">:</span> customersInLine<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 打印“Now serving Ewa!”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>注意</p> <p>过度使用 <code>autoclosures</code> 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</p></blockquote> <p>如果你想让一个自动闭包可以“逃逸”，则应该同时使用 <code>@autoclosure</code> 和 <code>@escaping</code> 属性。<code>@escaping</code> 属性的讲解见上面的 <a href="#%E9%80%83%E9%80%B8%E9%97%AD%E5%8C%85">逃逸闭包</a>。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token comment">// customersInLine i= [&quot;Barry&quot;, &quot;Daniella&quot;]</span>
<span class="token keyword">var</span> customerProviders<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">func</span> <span class="token function-definition function">collectCustomerProviders</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> customerProvider<span class="token punctuation">:</span> <span class="token attribute atrule">@autoclosure</span> <span class="token attribute atrule">@escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    customerProviders<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>customerProvider<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">collectCustomerProviders</span><span class="token punctuation">(</span>customersInLine<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">collectCustomerProviders</span><span class="token punctuation">(</span>customersInLine<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Collected </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">customerProviders<span class="token punctuation">.</span>count</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> closures.&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// 打印“Collected 2 closures.”</span>
<span class="token keyword">for</span> customerProvider <span class="token keyword">in</span> customerProviders <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Now serving </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token function">customerProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 打印“Now serving Barry!”</span>
<span class="token comment">// 打印“Now serving Daniella!”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在上面的代码中，<code>collectCustomerProviders(_:)</code> 函数并没有调用传入的 <code>customerProvider</code> 闭包，而是将闭包追加到了 <code>customerProviders</code> 数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包能够在函数返回之后被调用。因此，<code>customerProvider</code> 参数必须允许“逃逸”出函数作用域。</p></div></div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/05/07, 16:05:00</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/b69d99/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">函数</div></a> <a href="/pages/56276f/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">枚举</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/b69d99/" class="prev">函数</a></span> <span class="next"><a href="/pages/56276f/">枚举</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/742912/"><div>Homebrew+RVM+Ruby+CocoaPods</div></a> <span>11-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/81af2e/"><div>iOS13生命周期</div></a> <span>11-14</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/258164/"><div>《Swift编程语言》- 语法总结</div></a> <span>11-11</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div> <div class="comments-wrapper"><!----></div> </main></div> <!----> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">跟随系统</li><li class="iconfont icon-rijianmoshi">浅色模式</li><li class="iconfont icon-yejianmoshi">深色模式</li><li class="iconfont icon-yuedu">阅读模式</li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;filter:grayscale(100%);"></div> <!----> <div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f91ba302.js" defer></script><script src="/assets/js/2.dd713b59.js" defer></script><script src="/assets/js/3.069de0ac.js" defer></script><script src="/assets/js/19.7f321d7b.js" defer></script>
  </body>
</html>