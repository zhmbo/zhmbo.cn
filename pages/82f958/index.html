<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《Swift编程语言》- 协议 | zhmbo</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/img/favicon.ico">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/MouseClickEffect.js"></script>
    <script src="/js/FooterFish.js"></script>
    <meta name="description" content="zhmbo的技术博客,专注iOS技术分享,iOS,OC,Objective-C,Swift,SwiftUI,Apple,上架,Flutter,OpenGL,Xcode,Github,RxSwift,算法,架构,面试,zhmbo,zb,ZB,zhmbo,jumbo">
    <meta name="keywords" content="zhmbo,zhmbo,zhangbao,zhmbo的技术博客,个人博客,博客搭建,专注iOS技术分享,iOS,iOS进阶,iOS高级,OC,Objective-C,Swift,SwiftUI,Apple,上架,Flutter,OpenGL,Xcode,RxSwift,UIButton,UITableView,网络请求,Github,GithubActions,算法,架构,面试,zb,ZB,zhmbo,jumbo">
    <meta name="baidu-site-verification" content="code-l7ZsTFnxp5">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.8e525da2.css" as="style"><link rel="preload" href="/assets/js/app.f91ba302.js" as="script"><link rel="preload" href="/assets/js/2.dd713b59.js" as="script"><link rel="preload" href="/assets/js/3.069de0ac.js" as="script"><link rel="preload" href="/assets/js/33.b87269c8.js" as="script"><link rel="prefetch" href="/assets/js/10.eca7f202.js"><link rel="prefetch" href="/assets/js/100.884f2e2c.js"><link rel="prefetch" href="/assets/js/101.77e3c5d7.js"><link rel="prefetch" href="/assets/js/102.fbb46419.js"><link rel="prefetch" href="/assets/js/103.4285ab2f.js"><link rel="prefetch" href="/assets/js/104.b9d45e83.js"><link rel="prefetch" href="/assets/js/105.9af86ee7.js"><link rel="prefetch" href="/assets/js/106.f8baee69.js"><link rel="prefetch" href="/assets/js/107.fa4c186a.js"><link rel="prefetch" href="/assets/js/108.155cdba8.js"><link rel="prefetch" href="/assets/js/11.d5dc511b.js"><link rel="prefetch" href="/assets/js/12.126fd524.js"><link rel="prefetch" href="/assets/js/13.31add050.js"><link rel="prefetch" href="/assets/js/14.8f5927ce.js"><link rel="prefetch" href="/assets/js/15.5d73bb50.js"><link rel="prefetch" href="/assets/js/16.b7715387.js"><link rel="prefetch" href="/assets/js/17.b3336126.js"><link rel="prefetch" href="/assets/js/18.f0bd764d.js"><link rel="prefetch" href="/assets/js/19.7f321d7b.js"><link rel="prefetch" href="/assets/js/20.8a704687.js"><link rel="prefetch" href="/assets/js/21.6c9b4fd0.js"><link rel="prefetch" href="/assets/js/22.ce92c244.js"><link rel="prefetch" href="/assets/js/23.cbae088c.js"><link rel="prefetch" href="/assets/js/24.64936988.js"><link rel="prefetch" href="/assets/js/25.6ff36218.js"><link rel="prefetch" href="/assets/js/26.192e5aa3.js"><link rel="prefetch" href="/assets/js/27.5d49847d.js"><link rel="prefetch" href="/assets/js/28.865bfa0a.js"><link rel="prefetch" href="/assets/js/29.652b637f.js"><link rel="prefetch" href="/assets/js/30.2d2405ab.js"><link rel="prefetch" href="/assets/js/31.ff15975d.js"><link rel="prefetch" href="/assets/js/32.319807cb.js"><link rel="prefetch" href="/assets/js/34.2c88022c.js"><link rel="prefetch" href="/assets/js/35.090f353e.js"><link rel="prefetch" href="/assets/js/36.ef1f9b0b.js"><link rel="prefetch" href="/assets/js/37.ba5ce128.js"><link rel="prefetch" href="/assets/js/38.3c99d047.js"><link rel="prefetch" href="/assets/js/39.20a400e2.js"><link rel="prefetch" href="/assets/js/4.39a2702d.js"><link rel="prefetch" href="/assets/js/40.0f612174.js"><link rel="prefetch" href="/assets/js/41.c39b1818.js"><link rel="prefetch" href="/assets/js/42.73cd76fc.js"><link rel="prefetch" href="/assets/js/43.fec22db6.js"><link rel="prefetch" href="/assets/js/44.24cf9514.js"><link rel="prefetch" href="/assets/js/45.1a7bd4ad.js"><link rel="prefetch" href="/assets/js/46.2772e34b.js"><link rel="prefetch" href="/assets/js/47.b4eeef41.js"><link rel="prefetch" href="/assets/js/48.6e849ea1.js"><link rel="prefetch" href="/assets/js/49.e0c5a13d.js"><link rel="prefetch" href="/assets/js/5.5d94312a.js"><link rel="prefetch" href="/assets/js/50.773364d5.js"><link rel="prefetch" href="/assets/js/51.1db99b25.js"><link rel="prefetch" href="/assets/js/52.8c4dc63b.js"><link rel="prefetch" href="/assets/js/53.ebf1abab.js"><link rel="prefetch" href="/assets/js/54.016f21d7.js"><link rel="prefetch" href="/assets/js/55.73199a2d.js"><link rel="prefetch" href="/assets/js/56.3316e67d.js"><link rel="prefetch" href="/assets/js/57.57c6a9d7.js"><link rel="prefetch" href="/assets/js/58.65589959.js"><link rel="prefetch" href="/assets/js/59.abcabc64.js"><link rel="prefetch" href="/assets/js/6.8a416018.js"><link rel="prefetch" href="/assets/js/60.d382d1c3.js"><link rel="prefetch" href="/assets/js/61.c76620c7.js"><link rel="prefetch" href="/assets/js/62.44f03a5b.js"><link rel="prefetch" href="/assets/js/63.92fa470c.js"><link rel="prefetch" href="/assets/js/64.2475bc0a.js"><link rel="prefetch" href="/assets/js/65.e33c22e2.js"><link rel="prefetch" href="/assets/js/66.b213e189.js"><link rel="prefetch" href="/assets/js/67.54079f5f.js"><link rel="prefetch" href="/assets/js/68.9490fd8d.js"><link rel="prefetch" href="/assets/js/69.c9253eff.js"><link rel="prefetch" href="/assets/js/7.369ac24e.js"><link rel="prefetch" href="/assets/js/70.1c59f92a.js"><link rel="prefetch" href="/assets/js/71.3492471a.js"><link rel="prefetch" href="/assets/js/72.cec16c5f.js"><link rel="prefetch" href="/assets/js/73.50e8862b.js"><link rel="prefetch" href="/assets/js/74.086f16c5.js"><link rel="prefetch" href="/assets/js/75.5554210f.js"><link rel="prefetch" href="/assets/js/76.dfb35acc.js"><link rel="prefetch" href="/assets/js/77.440dde49.js"><link rel="prefetch" href="/assets/js/78.22d12fc4.js"><link rel="prefetch" href="/assets/js/79.7805a9b0.js"><link rel="prefetch" href="/assets/js/8.dd8ea451.js"><link rel="prefetch" href="/assets/js/80.0f6e99d9.js"><link rel="prefetch" href="/assets/js/81.775865b4.js"><link rel="prefetch" href="/assets/js/82.b0a6a6bc.js"><link rel="prefetch" href="/assets/js/83.b4431f89.js"><link rel="prefetch" href="/assets/js/84.9266dd31.js"><link rel="prefetch" href="/assets/js/85.6250c179.js"><link rel="prefetch" href="/assets/js/86.8def8d74.js"><link rel="prefetch" href="/assets/js/87.ae604169.js"><link rel="prefetch" href="/assets/js/88.ea0b4861.js"><link rel="prefetch" href="/assets/js/89.86dbd55a.js"><link rel="prefetch" href="/assets/js/9.d1ab447d.js"><link rel="prefetch" href="/assets/js/90.9225e7d0.js"><link rel="prefetch" href="/assets/js/91.f6bbf533.js"><link rel="prefetch" href="/assets/js/92.a7f31cba.js"><link rel="prefetch" href="/assets/js/93.540860df.js"><link rel="prefetch" href="/assets/js/94.2e3d73ab.js"><link rel="prefetch" href="/assets/js/95.e35292b9.js"><link rel="prefetch" href="/assets/js/96.c8174b05.js"><link rel="prefetch" href="/assets/js/97.f7b36c87.js"><link rel="prefetch" href="/assets/js/98.555706b2.js"><link rel="prefetch" href="/assets/js/99.70b5aa9a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8e525da2.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div class="width-limit"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link"><img src="https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/202407311741918.png" alt="zhmbo" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont jumbo-nav-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="iOS" class="dropdown-title"><a href="/ios/" class="link-title"><i class="iconfont jumbo-apple"></i>
      iOS
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-apple"></i>
      iOS
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>iOS开发精髓</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/3f0170/" class="nav-link"><i class="iconfont undefined"></i>
  介绍
</a></li><li class="dropdown-subitem"><a href="/pages/7354af/" class="nav-link"><i class="iconfont undefined"></i>
  从入门
</a></li><li class="dropdown-subitem"><a href="/pages/1b29d1/" class="nav-link"><i class="iconfont undefined"></i>
  到放弃
</a></li></ul></li><li class="dropdown-item"><h4>iOS充电宝</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/5cb5f0/" class="nav-link"><i class="iconfont undefined"></i>
  SwiftUI
</a></li><li class="dropdown-subitem"><a href="/pages/9e761f/" class="nav-link"><i class="iconfont undefined"></i>
  iOS14
</a></li><li class="dropdown-subitem"><a href="/pages/5e2170/" class="nav-link"><i class="iconfont undefined"></i>
  Xcode12
</a></li><li class="dropdown-subitem"><a href="/pages/554b82/" class="nav-link"><i class="iconfont undefined"></i>
  iOS周边
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Swift" class="dropdown-title"><a href="/swift/" class="link-title"><i class="iconfont jumbo-swift"></i>
      Swift
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-swift"></i>
      Swift
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/04ed05/" class="nav-link"><i class="iconfont undefined"></i>
  概览
</a></li><li class="dropdown-item"><!----> <a href="/pages/cf2b9a/" class="nav-link"><i class="iconfont undefined"></i>
  欢迎来到Swift
</a></li><li class="dropdown-item"><!----> <a href="/pages/9e2f81/" class="nav-link"><i class="iconfont undefined"></i>
  Swift语法
</a></li><li class="dropdown-item"><!----> <a href="/pages/581348/" class="nav-link"><i class="iconfont undefined"></i>
  语言参考
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title"><i class="iconfont jumbo-jishu"></i>
      技术
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-jishu"></i>
      技术
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/4f2c93/" class="nav-link"><i class="iconfont undefined"></i>
  博客
</a></li><li class="dropdown-item"><!----> <a href="/pages/6cbba7/" class="nav-link"><i class="iconfont undefined"></i>
  Github
</a></li><li class="dropdown-item"><!----> <a href="/pages/d9a627/" class="nav-link"><i class="iconfont undefined"></i>
  CocosCreator
</a></li><li class="dropdown-item"><!----> <a href="/pages/9af5e1/" class="nav-link"><i class="iconfont undefined"></i>
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/pages/46944a/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/pages/4b617e/" class="nav-link"><i class="iconfont undefined"></i>
  Android
</a></li><li class="dropdown-item"><!----> <a href="/pages/6ee1a4/" class="nav-link"><i class="iconfont undefined"></i>
  Git
</a></li></ul></div></div><div class="nav-item"><a href="/leaveword/" class="nav-link"><i class="iconfont jumbo-liuyan"></i>
  留言
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title"><i class="iconfont jumbo-suoyin"></i>
      索引
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-suoyin"></i>
      索引
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link"><i class="iconfont undefined"></i>
  分类
</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link"><i class="iconfont undefined"></i>
  标签
</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link"><i class="iconfont undefined"></i>
  归档
</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link"><i class="iconfont undefined"></i>
  友链
</a></li><li class="dropdown-item"><!----> <a href="/navigation/" class="nav-link"><i class="iconfont undefined"></i>
  导航
</a></li><li class="dropdown-item"><!----> <a href="/findme/" class="nav-link"><i class="iconfont undefined"></i>
  寻Me
</a></li></ul></div></div> <!----></nav></div></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/zhmbo/static@master/img/20200919111632.png"> <div class="blogger-info"><h3>@jumbo</h3> <span>an ios developer</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont jumbo-nav-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="iOS" class="dropdown-title"><a href="/ios/" class="link-title"><i class="iconfont jumbo-apple"></i>
      iOS
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-apple"></i>
      iOS
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>iOS开发精髓</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/3f0170/" class="nav-link"><i class="iconfont undefined"></i>
  介绍
</a></li><li class="dropdown-subitem"><a href="/pages/7354af/" class="nav-link"><i class="iconfont undefined"></i>
  从入门
</a></li><li class="dropdown-subitem"><a href="/pages/1b29d1/" class="nav-link"><i class="iconfont undefined"></i>
  到放弃
</a></li></ul></li><li class="dropdown-item"><h4>iOS充电宝</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/5cb5f0/" class="nav-link"><i class="iconfont undefined"></i>
  SwiftUI
</a></li><li class="dropdown-subitem"><a href="/pages/9e761f/" class="nav-link"><i class="iconfont undefined"></i>
  iOS14
</a></li><li class="dropdown-subitem"><a href="/pages/5e2170/" class="nav-link"><i class="iconfont undefined"></i>
  Xcode12
</a></li><li class="dropdown-subitem"><a href="/pages/554b82/" class="nav-link"><i class="iconfont undefined"></i>
  iOS周边
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Swift" class="dropdown-title"><a href="/swift/" class="link-title"><i class="iconfont jumbo-swift"></i>
      Swift
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-swift"></i>
      Swift
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/04ed05/" class="nav-link"><i class="iconfont undefined"></i>
  概览
</a></li><li class="dropdown-item"><!----> <a href="/pages/cf2b9a/" class="nav-link"><i class="iconfont undefined"></i>
  欢迎来到Swift
</a></li><li class="dropdown-item"><!----> <a href="/pages/9e2f81/" class="nav-link"><i class="iconfont undefined"></i>
  Swift语法
</a></li><li class="dropdown-item"><!----> <a href="/pages/581348/" class="nav-link"><i class="iconfont undefined"></i>
  语言参考
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title"><i class="iconfont jumbo-jishu"></i>
      技术
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-jishu"></i>
      技术
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/4f2c93/" class="nav-link"><i class="iconfont undefined"></i>
  博客
</a></li><li class="dropdown-item"><!----> <a href="/pages/6cbba7/" class="nav-link"><i class="iconfont undefined"></i>
  Github
</a></li><li class="dropdown-item"><!----> <a href="/pages/d9a627/" class="nav-link"><i class="iconfont undefined"></i>
  CocosCreator
</a></li><li class="dropdown-item"><!----> <a href="/pages/9af5e1/" class="nav-link"><i class="iconfont undefined"></i>
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/pages/46944a/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/pages/4b617e/" class="nav-link"><i class="iconfont undefined"></i>
  Android
</a></li><li class="dropdown-item"><!----> <a href="/pages/6ee1a4/" class="nav-link"><i class="iconfont undefined"></i>
  Git
</a></li></ul></div></div><div class="nav-item"><a href="/leaveword/" class="nav-link"><i class="iconfont jumbo-liuyan"></i>
  留言
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title"><i class="iconfont jumbo-suoyin"></i>
      索引
    </a> <span class="title" style="display:none;"><i class="iconfont jumbo-suoyin"></i>
      索引
    </span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link"><i class="iconfont undefined"></i>
  分类
</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link"><i class="iconfont undefined"></i>
  标签
</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link"><i class="iconfont undefined"></i>
  归档
</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link"><i class="iconfont undefined"></i>
  友链
</a></li><li class="dropdown-item"><!----> <a href="/navigation/" class="nav-link"><i class="iconfont undefined"></i>
  导航
</a></li><li class="dropdown-item"><!----> <a href="/findme/" class="nav-link"><i class="iconfont undefined"></i>
  寻Me
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/pages/04ed05/" class="sidebar-link">概览</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>欢迎来到Swift</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Swift语法</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9e2f81/" class="sidebar-link">基础知识</a></li><li><a href="/pages/279dd7/" class="sidebar-link">基本运算符</a></li><li><a href="/pages/2850e8/" class="sidebar-link">字符串和字符</a></li><li><a href="/pages/4b4c78/" class="sidebar-link">集合类型</a></li><li><a href="/pages/544cb0/" class="sidebar-link">控制流</a></li><li><a href="/pages/b69d99/" class="sidebar-link">函数</a></li><li><a href="/pages/7904a7/" class="sidebar-link">闭包</a></li><li><a href="/pages/56276f/" class="sidebar-link">枚举</a></li><li><a href="/pages/0641bb/" class="sidebar-link">类和结构体</a></li><li><a href="/pages/ce0459/" class="sidebar-link">属性</a></li><li><a href="/pages/efc653/" class="sidebar-link">方法</a></li><li><a href="/pages/e35887/" class="sidebar-link">下标</a></li><li><a href="/pages/09b0f4/" class="sidebar-link">继承</a></li><li><a href="/pages/1b072a/" class="sidebar-link">构造过程</a></li><li><a href="/pages/c40911/" class="sidebar-link">解析过程</a></li><li><a href="/pages/96b368/" class="sidebar-link">可选链</a></li><li><a href="/pages/cc5b2d/" class="sidebar-link">错误处理</a></li><li><a href="/pages/757c02/" class="sidebar-link">类型转换</a></li><li><a href="/pages/1d43f5/" class="sidebar-link">嵌套类型</a></li><li><a href="/pages/297d1c/" class="sidebar-link">扩展</a></li><li><a href="/pages/82f958/" aria-current="page" class="active sidebar-link">协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/82f958/#协议语法" class="sidebar-link">协议语法</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#属性要求" class="sidebar-link">属性要求</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#方法要求" class="sidebar-link">方法要求</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#异变方法要求" class="sidebar-link">异变方法要求</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#构造器要求" class="sidebar-link">构造器要求</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/82f958/#协议构造器要求的类实现" class="sidebar-link">协议构造器要求的类实现</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#可失败构造器要求" class="sidebar-link">可失败构造器要求</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/82f958/#协议作为类型" class="sidebar-link">协议作为类型</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#委托" class="sidebar-link">委托</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#在扩展里添加协议遵循" class="sidebar-link">在扩展里添加协议遵循</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#有条件地遵循协议" class="sidebar-link">有条件地遵循协议</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#在扩展里声明采纳协议" class="sidebar-link">在扩展里声明采纳协议</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#使用合成实现来采纳协议" class="sidebar-link">使用合成实现来采纳协议</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#协议类型的集合" class="sidebar-link">协议类型的集合</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#协议的继承" class="sidebar-link">协议的继承</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#类专属的协议" class="sidebar-link">类专属的协议</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#协议合成" class="sidebar-link">协议合成</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#检查协议一致性" class="sidebar-link">检查协议一致性</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#可选的协议要求" class="sidebar-link">可选的协议要求</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#协议扩展" class="sidebar-link">协议扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/82f958/#提供默认实现" class="sidebar-link">提供默认实现</a></li><li class="sidebar-sub-header"><a href="/pages/82f958/#为协议扩展添加限制条件" class="sidebar-link">为协议扩展添加限制条件</a></li></ul></li></ul></li><li><a href="/pages/0d8a5e/" class="sidebar-link">泛型</a></li><li><a href="/pages/46ff18/" class="sidebar-link">不透明类型</a></li><li><a href="/pages/51a2dd/" class="sidebar-link">自动引用计数</a></li><li><a href="/pages/9224f8/" class="sidebar-link">内存安全</a></li><li><a href="/pages/6c25a0/" class="sidebar-link">访问控制</a></li><li><a href="/pages/9854b9/" class="sidebar-link">高级运算符</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>语言参考</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"> <div class="theme-vdoing-wrapper bg-style-1"><div class="articleInfo-wrap" data-v-7e90c5a4><div class="articleInfo" data-v-7e90c5a4><ul class="breadcrumbs" data-v-7e90c5a4><li data-v-7e90c5a4><a href="/" title="首页" class="iconfont jumbo-home router-link-active" data-v-7e90c5a4></a></li> <li data-v-7e90c5a4><a href="/categories/?category=Swift%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80" title="分类" data-v-7e90c5a4>Swift编程语言</a></li> <li data-v-7e90c5a4><a href="/categories/?category=Swift%E8%AF%AD%E6%B3%95" title="分类" data-v-7e90c5a4>Swift语法</a></li></ul> <div class="info" data-v-7e90c5a4><div title="作者" class="author iconfont jumbo-author" data-v-7e90c5a4><a href="https://github.com/zhmbo" target="_blank" title="作者" class="beLink" data-v-7e90c5a4>zhmbo</a></div> <div title="创建时间" class="date iconfont jumbo-time" data-v-7e90c5a4><a href="javascript:;" data-v-7e90c5a4>2020-11-10</a></div> <div title="统计" class="date iconfont jumbo-eye" data-v-7e90c5a4><span id="/pages/82f958/" data-flag-title="《Swift编程语言》- 协议" class="leancloud-visitors" data-v-7e90c5a4><a class="leancloud-visitors-count" style="font-size:.7rem;font-weight:normal;color:#999;"></a></span></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          《Swift编程语言》- 协议
        </h1> <div class="theme-vdoing-content content__default"><p><em>协议</em> 定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。某个类型能够满足某个协议的要求，就可以说该类型<em>遵循</em>这个协议。</p> <p>除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。</p> <h2 id="协议语法"><a href="#协议语法" class="header-anchor">#</a> 协议语法</h2> <p>协议的定义方式与类、结构体和枚举的定义非常相似：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">SomeProtocol</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里是协议的定义部分</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>要让自定义类型遵循某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（<code>:</code>）分隔。遵循多个协议时，各协议之间用逗号（<code>,</code>）分隔：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">SomeStructure</span><span class="token punctuation">:</span> <span class="token class-name">FirstProtocol</span><span class="token punctuation">,</span> <span class="token class-name">AnotherProtocol</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里是结构体的定义部分</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>若是一个类拥有父类，应该将父类名放在遵循的协议名之前，以逗号分隔：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span> <span class="token class-name">SomeSuperClass</span><span class="token punctuation">,</span> <span class="token class-name">FirstProtocol</span><span class="token punctuation">,</span> <span class="token class-name">AnotherProtocol</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里是类的定义部分</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="属性要求"><a href="#属性要求" class="header-anchor">#</a> 属性要求</h2> <p>协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储属性还是计算属性，它只指定属性的名称和类型。此外，协议还指定属性是<em>可读</em>的还是<em>可读可写的</em>。</p> <p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。</p> <p>协议总是用 <code>var</code> 关键字来声明变量属性，在类型声明后加上 <code>{ set get }</code> 来表示属性是<em>可读可写</em>的，<em>可读</em>属性则用 <code>{ get }</code> 来表示：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">SomeProtocol</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> mustBeSettable<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token keyword">set</span> <span class="token punctuation">}</span>
    <span class="token keyword">var</span> doesNotNeedToBeSettable<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在协议中定义类型属性时，总是使用 <code>static</code> 关键字作为前缀。当类类型遵循协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字来声明类型属性：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">AnotherProtocol</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">var</span> someTypeProperty<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token keyword">set</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如下所示，这是一个只含有一个实例属性要求的协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">FullyNamed</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> fullName<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>FullyNamed</code> 协议除了要求遵循协议的类型提供 <code>fullName</code> 属性外，并没有其他特别的要求。这个协议表示，任何遵循 <code>FullyNamed</code> 的类型，都必须有一个可读的 <code>String</code> 类型的实例属性 <code>fullName</code>。</p> <p>下面是一个遵循 <code>FullyNamed</code> 协议的简单结构体：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token class-name">FullyNamed</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> fullName<span class="token punctuation">:</span> <span class="token class-name">String</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> john <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>fullName<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;John Appleseed&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// john.fullName 为 &quot;John Appleseed&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这个例子中定义了一个叫做 <code>Person</code> 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它遵循了 <code>FullyNamed</code> 协议。</p> <p><code>Person</code> 结构体的每一个实例都有一个 <code>String</code> 类型的存储型属性 <code>fullName</code>。这正好满足了 <code>FullyNamed</code> 协议的要求，也就意味着 <code>Person</code> 结构体正确地遵循了协议。（如果协议要求未被完全满足，在编译时会报错。）</p> <p>下面是一个更为复杂的类，它采纳并遵循了 <code>FullyNamed</code> 协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">Starship</span><span class="token punctuation">:</span> <span class="token class-name">FullyNamed</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token keyword">prefix</span><span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">prefix</span><span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token nil constant">nil</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token keyword">prefix</span> <span class="token operator">=</span> <span class="token keyword">prefix</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> fullName<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">prefix</span> <span class="token operator">!=</span> <span class="token nil constant">nil</span> <span class="token operator">?</span> <span class="token keyword">prefix</span><span class="token operator">!</span> <span class="token operator">+</span> <span class="token string-literal"><span class="token string">&quot; &quot;</span></span> <span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;&quot;</span></span><span class="token punctuation">)</span> <span class="token operator">+</span> name
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> ncc1701 <span class="token operator">=</span> <span class="token class-name">Starship</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Enterprise&quot;</span></span><span class="token punctuation">,</span> <span class="token keyword">prefix</span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;USS&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// ncc1701.fullName 为 &quot;USS Enterprise&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><code>Starship</code> 类把 <code>fullName</code> 作为只读的计算属性来实现。每一个 <code>Starship</code> 类的实例都有一个名为 <code>name</code> 的非可选属性和一个名为 <code>prefix</code> 的可选属性。 当 <code>prefix</code> 存在时，计算属性 <code>fullName</code> 会将 <code>prefix</code> 插入到 <code>name</code> 之前，从而得到一个带有 <code>prefix</code> 的 <code>fullName</code>。</p> <h2 id="方法要求"><a href="#方法要求" class="header-anchor">#</a> 方法要求</h2> <p>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法提供默认参数。</p> <p>正如属性要求中所述，在协议中定义类方法的时候，总是使用 <code>static</code> 关键字作为前缀。即使在类实现时，类方法要求使用 <code>class</code> 或 <code>static</code> 作为关键字前缀，前面的规则仍然适用：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">SomeProtocol</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function-definition function">someTypeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>下面的例子定义了一个只含有一个实例方法的协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">RandomNumberGenerator</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function-definition function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Double</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>RandomNumberGenerator</code> 协议要求遵循协议的类型必须拥有一个名为 <code>random</code>， 返回值类型为 <code>Double</code> 的实例方法。尽管这里并未指明，但是我们假设返回值是从 <code>0.0</code> 到（但不包括）<code>1.0</code>。</p> <p><code>RandomNumberGenerator</code> 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。</p> <p>如下所示，下边是一个遵循并符合 <code>RandomNumberGenerator</code> 协议的类。该类实现了一个叫做 <em>线性同余生成器（linear congruential generator）</em> 的伪随机数算法。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">LinearCongruentialGenerator</span><span class="token punctuation">:</span> <span class="token class-name">RandomNumberGenerator</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> lastRandom <span class="token operator">=</span> <span class="token number">42.0</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token number">139968.0</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">3877.0</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">29573.0</span>
    <span class="token keyword">func</span> <span class="token function-definition function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Double</span> <span class="token punctuation">{</span>
        lastRandom <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>lastRandom <span class="token operator">*</span> a <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">truncatingRemainder</span><span class="token punctuation">(</span>dividingBy<span class="token punctuation">:</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> lastRandom <span class="token operator">/</span> m
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> generator <span class="token operator">=</span> <span class="token class-name">LinearCongruentialGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Here's a random number: </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">generator<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// 打印 “Here's a random number: 0.37464991998171”</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;And another one: </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">generator<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// 打印 “And another one: 0.729023776863283”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="异变方法要求"><a href="#异变方法要求" class="header-anchor">#</a> 异变方法要求</h2> <p>有时需要在方法中改变（或<em>异变</em>）方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 <code>mutating</code> 关键字作为方法的前缀，写在 <code>func</code> 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。这一过程在 <a href="/pages/efc653/#在实例方法中修改值类型">在实例方法中修改值类型</a> 章节中有详细描述。</p> <p>如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 <code>mutating</code> 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。</p> <blockquote><p>注意</p> <p>实现协议中的 <code>mutating</code> 方法时，若是类类型，则不用写 <code>mutating</code> 关键字。而对于结构体和枚举，则必须写 <code>mutating</code> 关键字。</p></blockquote> <p>如下所示，<code>Togglable</code> 协议只定义了一个名为 <code>toggle</code> 的实例方法。顾名思义，<code>toggle()</code> 方法将改变实例属性，从而切换遵循该协议类型的实例的状态。</p> <p><code>toggle()</code> 方法在定义的时候，使用 <code>mutating</code> 关键字标记，这表明当它被调用时，该方法将会改变遵循协议的类型的实例：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">Togglable</span> <span class="token punctuation">{</span>
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">toggle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当使用枚举或结构体来实现 <code>Togglable</code> 协议时，需要提供一个带有 <code>mutating</code> 前缀的 <code>toggle()</code> 方法。</p> <p>下面定义了一个名为 <code>OnOffSwitch</code> 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 <code>On</code> 和 <code>Off</code> 表示。枚举的 <code>toggle()</code> 方法被标记为 <code>mutating</code>，以满足 <code>Togglable</code> 协议的要求：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">enum</span> <span class="token class-name">OnOffSwitch</span><span class="token punctuation">:</span> <span class="token class-name">Togglable</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> off<span class="token punctuation">,</span> on
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">toggle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token punctuation">.</span>off<span class="token punctuation">:</span>
            <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span>on
        <span class="token keyword">case</span> <span class="token punctuation">.</span>on<span class="token punctuation">:</span>
            <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span>off
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> lightSwitch <span class="token operator">=</span> <span class="token class-name">OnOffSwitch</span><span class="token punctuation">.</span>off
lightSwitch<span class="token punctuation">.</span><span class="token function">toggle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// lightSwitch 现在的值为 .on</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="构造器要求"><a href="#构造器要求" class="header-anchor">#</a> 构造器要求</h2> <p>协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">SomeProtocol</span> <span class="token punctuation">{</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>someParameter<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="协议构造器要求的类实现"><a href="#协议构造器要求的类实现" class="header-anchor">#</a> 协议构造器要求的类实现</h3> <p>你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span> <span class="token class-name">SomeProtocol</span> <span class="token punctuation">{</span>
    <span class="token keyword">required</span> <span class="token keyword">init</span><span class="token punctuation">(</span>someParameter<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是构造器的实现部分</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>使用 <code>required</code> 修饰符可以确保所有子类也必须提供此构造器实现，从而也能遵循协议。</p> <p>关于 <code>required</code> 构造器的更多内容，请参考 <a href="/pages/1b072a/#必要构造器">必要构造器</a>。</p> <blockquote><p>注意</p> <p>如果类已经被标记为 <code>final</code>，那么不需要在协议构造器的实现中使用 <code>required</code> 修饰符，因为 <code>final</code> 类不能有子类。关于 <code>final</code> 修饰符的更多内容，请参见 <a href="/pages/09b0f4/#防止重写">防止重写</a>。</p></blockquote> <p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">SomeProtocol</span> <span class="token punctuation">{</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">SomeSuperClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是构造器的实现部分</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">SomeSubClass</span><span class="token punctuation">:</span> <span class="token class-name">SomeSuperClass</span><span class="token punctuation">,</span> <span class="token class-name">SomeProtocol</span> <span class="token punctuation">{</span>
    <span class="token comment">// 因为遵循协议，需要加上 required</span>
    <span class="token comment">// 因为继承自父类，需要加上 override</span>
    <span class="token keyword">required</span> <span class="token keyword">override</span> <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是构造器的实现部分</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="可失败构造器要求"><a href="#可失败构造器要求" class="header-anchor">#</a> 可失败构造器要求</h3> <p>协议还可以为遵循协议的类型定义可失败构造器要求，详见 <a href="/pages/1b072a/#可失败构造器">可失败构造器</a>。</p> <p>遵循协议的类型可以通过可失败构造器（<code>init?</code>）或非可失败构造器（<code>init</code>）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（<code>init</code>）或隐式解包可失败构造器（<code>init!</code>）来满足。</p> <h2 id="协议作为类型"><a href="#协议作为类型" class="header-anchor">#</a> 协议作为类型</h2> <p>尽管协议本身并未实现任何功能，但是协议可以被当做一个功能完备的类型来使用。协议作为类型使用，有时被称作「存在类型」，这个名词来自「存在着一个类型 T，该类型遵循协议 T」。</p> <p>协议可以像其他普通类型一样使用，使用场景如下：</p> <ul><li>作为函数、方法或构造器中的参数类型或返回值类型</li> <li>作为常量、变量或属性的类型</li> <li>作为数组、字典或其他容器中的元素类型</li></ul> <blockquote><p>注意</p> <p>协议是一种类型，因此协议类型的名称应与其他类型（例如 <code>Int</code>，<code>Double</code>，<code>String</code>）的写法相同，使用大写字母开头的驼峰式写法，例如（<code>FullyNamed</code> 和 <code>RandomNumberGenerator</code>）。</p></blockquote> <p>下面是将协议作为类型使用的例子：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">Dice</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sides<span class="token punctuation">:</span> <span class="token class-name">Int</span>
    <span class="token keyword">let</span> generator<span class="token punctuation">:</span> <span class="token class-name">RandomNumberGenerator</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>sides<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> generator<span class="token punctuation">:</span> <span class="token class-name">RandomNumberGenerator</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>sides <span class="token operator">=</span> sides
        <span class="token keyword">self</span><span class="token punctuation">.</span>generator <span class="token operator">=</span> generator
    <span class="token punctuation">}</span>
    <span class="token keyword">func</span> <span class="token function-definition function">roll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Int</span><span class="token punctuation">(</span>generator<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Double</span><span class="token punctuation">(</span>sides<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>例子中定义了一个 <code>Dice</code> 类，用来代表桌游中拥有 N 个面的骰子。<code>Dice</code> 的实例含有 <code>sides</code> 和 <code>generator</code> 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。</p> <p><code>generator</code> 属性的类型为 <code>RandomNumberGenerator</code>，因此任何遵循了 <code>RandomNumberGenerator</code> 协议的类型的实例都可以赋值给 <code>generator</code>，除此之外并无其他要求。并且由于其类型是 <code>RandomNumberGenerator</code>，在 <code>Dice</code> 类中与 <code>generator</code> 交互的代码，必须适用于所有 <code>generator</code> 实例都遵循的方法。这句话的意思是不能使用由 <code>generator</code> 底层类型提供的任何方法或属性。但是你可以通过向下转型，从协议类型转换成底层实现类型，比如从父类向下转型为子类。请参考 <a href="/pages/757c02/#向下转型">向下转型</a>。</p> <p><code>Dice</code> 类还有一个构造器，用来设置初始状态。构造器有一个名为 <code>generator</code>，类型为 <code>RandomNumberGenerator</code> 的形参。在调用构造方法创建 <code>Dice</code> 的实例时，可以传入任何遵循 <code>RandomNumberGenerator</code> 协议的实例给 <code>generator</code>。</p> <p><code>Dice</code> 类提供了一个名为 <code>roll</code> 的实例方法，用来模拟骰子的面值。它先调用 <code>generator</code> 的 <code>random()</code> 方法来生成一个 <code>[0.0,1.0)</code> 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 <code>generator</code> 遵循了 <code>RandomNumberGenerator</code> 协议，可以确保它有个 <code>random()</code> 方法可供调用。</p> <p>下面的例子展示了如何使用 <code>LinearCongruentialGenerator</code> 的实例作为随机数生成器来创建一个六面骰子：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">var</span> d6 <span class="token operator">=</span> <span class="token class-name">Dice</span><span class="token punctuation">(</span>sides<span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span> generator<span class="token punctuation">:</span> <span class="token class-name">LinearCongruentialGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token omit keyword">_</span> <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">...</span><span class="token number">5</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Random dice roll is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">d6<span class="token punctuation">.</span><span class="token function">roll</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// Random dice roll is 3</span>
<span class="token comment">// Random dice roll is 5</span>
<span class="token comment">// Random dice roll is 4</span>
<span class="token comment">// Random dice roll is 5</span>
<span class="token comment">// Random dice roll is 4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="委托"><a href="#委托" class="header-anchor">#</a> 委托</h2> <p><em>委托</em>是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p> <p>下面的例子定义了两个基于骰子游戏的协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">DiceGame</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> dice<span class="token punctuation">:</span> <span class="token class-name">Dice</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
    <span class="token keyword">func</span> <span class="token function-definition function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">protocol</span> <span class="token class-name">DiceGameDelegate</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function-definition function">gameDidStart</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> game<span class="token punctuation">:</span> <span class="token class-name">DiceGame</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function-definition function">game</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> game<span class="token punctuation">:</span> <span class="token class-name">DiceGame</span><span class="token punctuation">,</span> didStartNewTurnWithDiceRoll diceRoll<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function-definition function">gameDidEnd</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> game<span class="token punctuation">:</span> <span class="token class-name">DiceGame</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>DiceGame</code> 协议可以被任意涉及骰子的游戏遵循。</p> <p><code>DiceGameDelegate</code> 协议可以被任意类型遵循，用来追踪 <code>DiceGame</code> 的游戏过程。为了防止强引用导致的循环引用问题，可以把协议声明为弱引用，更多相关的知识请看 <a href="/pages/51a2dd/#类实例之间的循环强引用">类实例之间的循环强引用</a>，当协议标记为类专属可以使 <code>SnakesAndLadders</code> 类在声明协议时强制要使用弱引用。若要声明类专属的协议就必须继承于 <code>AnyObject</code> ，更多请看 <a href="#%E7%B1%BB%E4%B8%93%E5%B1%9E%E7%9A%84%E5%8D%8F%E8%AE%AE">类专属的协议</a>。</p> <p>如下所示，<code>SnakesAndLadders</code> 是 <a href="/pages/544cb0/">控制流</a> 章节引入的蛇梯棋游戏的新版本。新版本使用 <code>Dice</code> 实例作为骰子，并且实现了 <code>DiceGame</code> 和 <code>DiceGameDelegate</code> 协议，后者用来记录游戏的过程：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">SnakesAndLadders</span><span class="token punctuation">:</span> <span class="token class-name">DiceGame</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> finalSquare <span class="token operator">=</span> <span class="token number">25</span>
    <span class="token keyword">let</span> dice <span class="token operator">=</span> <span class="token class-name">Dice</span><span class="token punctuation">(</span>sides<span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span> generator<span class="token punctuation">:</span> <span class="token class-name">LinearCongruentialGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> square <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">var</span> board<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        board <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">:</span> finalSquare <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        board<span class="token punctuation">[</span><span class="token number">03</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">+</span><span class="token number">08</span><span class="token punctuation">;</span> board<span class="token punctuation">[</span><span class="token number">06</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">+</span><span class="token number">11</span><span class="token punctuation">;</span> board<span class="token punctuation">[</span><span class="token number">09</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">+</span><span class="token number">09</span><span class="token punctuation">;</span> board<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">+</span><span class="token number">02</span>
        board<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span> board<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">;</span> board<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">02</span><span class="token punctuation">;</span> board<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">08</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> delegate<span class="token punctuation">:</span> <span class="token class-name">DiceGameDelegate</span><span class="token operator">?</span>
    <span class="token keyword">func</span> <span class="token function-definition function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        square <span class="token operator">=</span> <span class="token number">0</span>
        delegate<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">gameDidStart</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>
        <span class="token label important">gameLoop</span><span class="token punctuation">:</span> <span class="token keyword">while</span> square <span class="token operator">!=</span> finalSquare <span class="token punctuation">{</span>
            <span class="token keyword">let</span> diceRoll <span class="token operator">=</span> dice<span class="token punctuation">.</span><span class="token function">roll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            delegate<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">game</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> didStartNewTurnWithDiceRoll<span class="token punctuation">:</span> diceRoll<span class="token punctuation">)</span>
            <span class="token keyword">switch</span> square <span class="token operator">+</span> diceRoll <span class="token punctuation">{</span>
            <span class="token keyword">case</span> finalSquare<span class="token punctuation">:</span>
                <span class="token keyword">break</span><span class="token label important"> gameLoop</span>
            <span class="token keyword">case</span> <span class="token keyword">let</span> newSquare <span class="token keyword">where</span> newSquare <span class="token operator">&gt;</span> finalSquare<span class="token punctuation">:</span>
                <span class="token keyword">continue</span><span class="token label important"> gameLoop</span>
            <span class="token keyword">default</span><span class="token punctuation">:</span>
                square <span class="token operator">+=</span> diceRoll
                square <span class="token operator">+=</span> board<span class="token punctuation">[</span>square<span class="token punctuation">]</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        delegate<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">gameDidEnd</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>关于这个<em>蛇梯棋</em>游戏的详细描述请参阅 <a href="/pages/544cb0/#break">中断（Break）</a>。</p> <p>这个版本的游戏封装到了 <code>SnakesAndLadders</code> 类中，该类遵循了 <code>DiceGame</code> 协议，并且提供了相应的可读的 <code>dice</code> 属性和 <code>play()</code> 方法。（ <code>dice</code> 属性在构造之后就不再改变，且协议只要求 <code>dice</code> 为可读的，因此将 <code>dice</code> 声明为常量属性。）</p> <p>游戏使用 <code>SnakesAndLadders</code> 类的 <code>init()</code> 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 <code>play()</code> 方法，<code>play()</code> 方法使用协议要求的 <code>dice</code> 属性提供骰子摇出的值。</p> <p>注意，<code>delegate</code> 并不是游戏的必备条件，因此 <code>delegate</code> 被定义为 <code>DiceGameDelegate</code> 类型的可选属性。因为 <code>delegate</code> 是可选值，因此会被自动赋予初始值 <code>nil</code>。随后，可以在游戏中为 <code>delegate</code> 设置适当的值。因为 <code>DiceGameDelegate</code> 协议是类专属的，可以将 <code>delegate</code> 声明为 <code>weak</code>，从而避免循环引用。</p> <p><code>DicegameDelegate</code> 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 <code>play()</code> 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。</p> <p>因为 <code>delegate</code> 是一个 <code>DiceGameDelegate</code> 类型的可选属性，因此在 <code>play()</code> 方法中通过可选链式调用来调用它的方法。若 <code>delegate</code> 属性为 <code>nil</code>，则调用方法会优雅地失败，并不会产生错误。若 <code>delegate</code> 不为 <code>nil</code>，则方法能够被调用，并传递 <code>SnakesAndLadders</code> 实例作为参数。</p> <p>如下示例定义了 <code>DiceGameTracker</code> 类，它遵循了 <code>DiceGameDelegate</code> 协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">DiceGameTracker</span><span class="token punctuation">:</span> <span class="token class-name">DiceGameDelegate</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> numberOfTurns <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">func</span> <span class="token function-definition function">gameDidStart</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> game<span class="token punctuation">:</span> <span class="token class-name">DiceGame</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        numberOfTurns <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">if</span> game <span class="token keyword">is</span> <span class="token class-name">SnakesAndLadders</span> <span class="token punctuation">{</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Started a new game of Snakes and Ladders&quot;</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The game is using a </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">game<span class="token punctuation">.</span>dice<span class="token punctuation">.</span>sides</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">-sided dice&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">func</span> <span class="token function-definition function">game</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> game<span class="token punctuation">:</span> <span class="token class-name">DiceGame</span><span class="token punctuation">,</span> didStartNewTurnWithDiceRoll diceRoll<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        numberOfTurns <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Rolled a </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">diceRoll</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">func</span> <span class="token function-definition function">gameDidEnd</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> game<span class="token punctuation">:</span> <span class="token class-name">DiceGame</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The game lasted for </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">numberOfTurns</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> turns&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><code>DiceGameTracker</code> 实现了 <code>DiceGameDelegate</code> 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，<code>numberOfTurns</code> 属性被赋值为 <code>0</code>，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。</p> <p><code>gameDidStart(_:)</code> 方法从 <code>game</code> 参数获取游戏信息并打印。<code>game</code> 参数是 <code>DiceGame</code> 类型而不是 <code>SnakeAndLadders</code> 类型，所以在 <code>gameDidStart(_:)</code> 方法中只能访问 <code>DiceGame</code> 协议中的内容。当然了，<code>SnakeAndLadders</code> 的方法也可以在类型转换之后调用。在上例代码中，通过 <code>is</code> 操作符检查 <code>game</code> 是否为 <code>SnakesAndLadders</code> 类型的实例，如果是，则打印出相应的消息。</p> <p>无论当前进行的是何种游戏，由于 <code>game</code> 遵循 <code>DiceGame</code> 协议，可以确保 <code>game</code> 含有 <code>dice</code> 属性。因此在 <code>gameDidStart(_:)</code> 方法中可以通过传入的 <code>game</code> 参数来访问 <code>dice</code> 属性，进而打印出 <code>dice</code> 的 <code>sides</code> 属性的值。</p> <p><code>DiceGameTracker</code> 的运行情况如下所示：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> tracker <span class="token operator">=</span> <span class="token class-name">DiceGameTracker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> game <span class="token operator">=</span> <span class="token class-name">SnakesAndLadders</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
game<span class="token punctuation">.</span>delegate <span class="token operator">=</span> tracker
game<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// Started a new game of Snakes and Ladders</span>
<span class="token comment">// The game is using a 6-sided dice</span>
<span class="token comment">// Rolled a 3</span>
<span class="token comment">// Rolled a 5</span>
<span class="token comment">// Rolled a 4</span>
<span class="token comment">// Rolled a 5</span>
<span class="token comment">// The game lasted for 4 turns</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="在扩展里添加协议遵循"><a href="#在扩展里添加协议遵循" class="header-anchor">#</a> 在扩展里添加协议遵循</h2> <p>即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。详情请在 <a href="/pages/297d1c/">扩展</a> 章节中查看。</p> <blockquote><p>注意</p> <p>通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p></blockquote> <p>例如下面这个 <code>TextRepresentable</code> 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">TextRepresentable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> textualDescription<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以通过扩展，令先前提到的 <code>Dice</code> 类可以扩展来采纳和遵循 <code>TextRepresentable</code> 协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">extension</span> <span class="token class-name">Dice</span><span class="token punctuation">:</span> <span class="token class-name">TextRepresentable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> textualDescription<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">&quot;A </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">sides</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">-sided dice&quot;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>通过扩展遵循并采纳协议，和在原始定义中遵循并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。</p> <p>现在所有 <code>Dice</code> 的实例都可以看做 <code>TextRepresentable</code> 类型：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> d12 <span class="token operator">=</span> <span class="token class-name">Dice</span><span class="token punctuation">(</span>sides<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span> generator<span class="token punctuation">:</span> <span class="token class-name">LinearCongruentialGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>d12<span class="token punctuation">.</span>textualDescription<span class="token punctuation">)</span>
<span class="token comment">// 打印 “A 12-sided dice”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>同样，<code>SnakesAndLadders</code> 类也可以通过扩展来采纳和遵循 <code>TextRepresentable</code> 协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">extension</span> <span class="token class-name">SnakesAndLadders</span><span class="token punctuation">:</span> <span class="token class-name">TextRepresentable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> textualDescription<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">&quot;A game of Snakes and Ladders with </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">finalSquare</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> squares&quot;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span>game<span class="token punctuation">.</span>textualDescription<span class="token punctuation">)</span>
<span class="token comment">// 打印 “A game of Snakes and Ladders with 25 squares”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="有条件地遵循协议"><a href="#有条件地遵循协议" class="header-anchor">#</a> 有条件地遵循协议</h2> <p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。你可以通过在扩展类型时列出限制让泛型类型有条件地遵循某协议。在你采纳协议的名字后面写泛型 <code>where</code> 分句。更多关于泛型 <code>where</code> 分句，见 <a href="/pages/0d8a5e/#泛型-where-语句">泛型 Where 分句</a>。</p> <p>下面的扩展让 <code>Array</code> 类型只要在存储遵循 <code>TextRepresentable</code> 协议的元素时就遵循 <code>TextRepresentable</code> 协议。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">extension</span> <span class="token class-name">Array</span><span class="token punctuation">:</span> <span class="token class-name">TextRepresentable</span> <span class="token keyword">where</span> <span class="token class-name">Element</span><span class="token punctuation">:</span> <span class="token class-name">TextRepresentable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> textualDescription<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> itemsAsText <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>map <span class="token punctuation">{</span> <span class="token short-argument">$0</span><span class="token punctuation">.</span>textualDescription <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">&quot;[&quot;</span></span> <span class="token operator">+</span> itemsAsText<span class="token punctuation">.</span><span class="token function">joined</span><span class="token punctuation">(</span>separator<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;, &quot;</span></span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string-literal"><span class="token string">&quot;]&quot;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> myDice <span class="token operator">=</span> <span class="token punctuation">[</span>d6<span class="token punctuation">,</span> d12<span class="token punctuation">]</span>
<span class="token function">print</span><span class="token punctuation">(</span>myDice<span class="token punctuation">.</span>textualDescription<span class="token punctuation">)</span>
<span class="token comment">// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="在扩展里声明采纳协议"><a href="#在扩展里声明采纳协议" class="header-anchor">#</a> 在扩展里声明采纳协议</h2> <p>当一个类型已经遵循了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空的扩展来让它采纳该协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Hamster</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
       <span class="token keyword">var</span> textualDescription<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">&quot;A hamster named </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">name</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">extension</span> <span class="token class-name">Hamster</span><span class="token punctuation">:</span> <span class="token class-name">TextRepresentable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>从现在起，<code>Hamster</code> 的实例可以作为 <code>TextRepresentable</code> 类型使用：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> simonTheHamster <span class="token operator">=</span> <span class="token class-name">Hamster</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Simon&quot;</span></span><span class="token punctuation">)</span>
<span class="token keyword">let</span> somethingTextRepresentable<span class="token punctuation">:</span> <span class="token class-name">TextRepresentable</span> <span class="token operator">=</span> simonTheHamster
<span class="token function">print</span><span class="token punctuation">(</span>somethingTextRepresentable<span class="token punctuation">.</span>textualDescription<span class="token punctuation">)</span>
<span class="token comment">// 打印 “A hamster named Simon”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>注意</p> <p>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。</p></blockquote> <h2 id="使用合成实现来采纳协议"><a href="#使用合成实现来采纳协议" class="header-anchor">#</a> 使用合成实现来采纳协议</h2> <p>Swift 可以自动提供一些简单场景下遵循 <code>Equatable</code>、<code>Hashable</code> 和 <code>Comparable</code> 协议的实现。在使用这些合成实现之后，无需再编写重复的代码来实现这些协议所要求的方法。</p> <p>Swift 为以下几种自定义类型提供了 <code>Equatable</code> 协议的合成实现：</p> <ul><li>遵循 <code>Equatable</code> 协议且只有存储属性的结构体。</li> <li>遵循 <code>Equatable</code> 协议且只有关联类型的枚举</li> <li>没有任何关联类型的枚举</li></ul> <p>在包含类型原始声明的文件中声明对 <code>Equatable</code> 协议的遵循，可以得到 <code>==</code> 操作符的合成实现，且无需自己编写任何关于 <code>==</code> 的实现代码。<code>Equatable</code> 协议同时包含 <code>!=</code> 操作符的默认实现。</p> <p>下面的例子中定义了一个 <code>Vector3D</code> 结构体来表示一个类似 <code>Vector2D</code> 的三维向量 <code>(x, y, z)</code>。由于 <code>x</code>、<code>y</code> 和 <code>z</code> 都是满足 <code>Equatable</code> 的类型，<code>Vector3D</code> 可以得到连等判断的合成实现。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Vector3D</span><span class="token punctuation">:</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token number">0.0</span>
<span class="token punctuation">}</span>


<span class="token keyword">let</span> twoThreeFour <span class="token operator">=</span> <span class="token class-name">Vector3D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">2.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">4.0</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> anotherTwoThreeFour <span class="token operator">=</span> <span class="token class-name">Vector3D</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">2.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">4.0</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> twoThreeFour <span class="token operator">==</span> anotherTwoThreeFour <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;These two vectors are also equivalent.&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 打印 &quot;These two vectors are also equivalent.&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Swift 为以下几种自定义类型提供了 <code>Hashable</code> 协议的合成实现：</p> <ul><li>遵循 <code>Hashable</code> 协议且只有存储属性的结构体。</li> <li>遵循 <code>Hashable</code> 协议且只有关联类型的枚举</li> <li>没有任何关联类型的枚举</li></ul> <p>在包含类型原始声明的文件中声明对 <code>Hashable</code> 协议的遵循，可以得到 <code>hash(into:)</code> 的合成实现，且无需自己编写任何关于 <code>hash(into:)</code> 的实现代码。</p> <p>Swift 为没有原始值的枚举类型提供了 <code>Comparable</code> 协议的合成实现。如果枚举类型包含关联类型，那这些关联类型也必须同时遵循 <code>Comparable</code> 协议。在包含原始枚举类型声明的文件中声明其对 <code>Comparable</code> 协议的遵循，可以得到 <code>&lt;</code> 操作符的合成实现，且无需自己编写任何关于 <code>&lt;</code> 的实现代码。<code>Comparable</code> 协议同时包含 <code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code> 操作符的默认实现。</p> <p>下面的例子中定义了 <code>SkillLevel</code> 枚举类型，其中定义了初学者（beginner）、中级（intermediate）和专家（expert）三种等级，专家等级会由额外的星级（stars）来进行排名。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">enum</span> <span class="token class-name">SkillLevel</span><span class="token punctuation">:</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> beginner
    <span class="token keyword">case</span> intermediate
    <span class="token keyword">case</span> <span class="token function">expert</span><span class="token punctuation">(</span>stars<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> levels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token class-name">SkillLevel</span><span class="token punctuation">.</span>intermediate<span class="token punctuation">,</span> <span class="token class-name">SkillLevel</span><span class="token punctuation">.</span>beginner<span class="token punctuation">,</span>
              <span class="token class-name">SkillLevel</span><span class="token punctuation">.</span><span class="token function">expert</span><span class="token punctuation">(</span>stars<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">SkillLevel</span><span class="token punctuation">.</span><span class="token function">expert</span><span class="token punctuation">(</span>stars<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> level <span class="token keyword">in</span> levels<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 打印 &quot;beginner&quot;</span>
<span class="token comment">// 打印 &quot;intermediate&quot;</span>
<span class="token comment">// 打印 &quot;expert(stars: 3)&quot;</span>
<span class="token comment">// 打印 &quot;expert(stars: 5)&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="协议类型的集合"><a href="#协议类型的集合" class="header-anchor">#</a> 协议类型的集合</h2> <p>协议类型可以在数组或者字典这样的集合中使用，在 <a href="#%E5%8D%8F%E8%AE%AE%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B">协议类型</a> 提到了这样的用法。下面的例子创建了一个元素类型为 <code>TextRepresentable</code> 的数组：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> things<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">TextRepresentable</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>game<span class="token punctuation">,</span> d12<span class="token punctuation">,</span> simonTheHamster<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如下所示，可以遍历 <code>things</code> 数组，并打印每个元素的文本表示：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">for</span> thing <span class="token keyword">in</span> things <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span>thing<span class="token punctuation">.</span>textualDescription<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// A game of Snakes and Ladders with 25 squares</span>
<span class="token comment">// A 12-sided dice</span>
<span class="token comment">// A hamster named Simon</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>注意 <code>thing</code> 常量是 <code>TextRepresentable</code> 类型而不是 <code>Dice</code>，<code>DiceGame</code>，<code>Hamster</code> 等类型，即使实例在幕后确实是这些类型中的一种。由于 <code>thing</code> 是 <code>TextRepresentable</code> 类型，任何 <code>TextRepresentable</code> 的实例都有一个 <code>textualDescription</code> 属性，所以在每次循环中可以安全地访问 <code>thing.textualDescription</code>。</p> <h2 id="协议的继承"><a href="#协议的继承" class="header-anchor">#</a> 协议的继承</h2> <p>协议能够<em>继承</em>一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">InheritingProtocol</span><span class="token punctuation">:</span> <span class="token class-name">SomeProtocol</span><span class="token punctuation">,</span> <span class="token class-name">AnotherProtocol</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里是协议的定义部分</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如下所示，<code>PrettyTextRepresentable</code> 协议继承了 <code>TextRepresentable</code> 协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">PrettyTextRepresentable</span><span class="token punctuation">:</span> <span class="token class-name">TextRepresentable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prettyTextualDescription<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>例子中定义了一个新的协议 <code>PrettyTextRepresentable</code>，它继承自 <code>TextRepresentable</code> 协议。任何遵循 <code>PrettyTextRepresentable</code> 协议的类型在满足该协议的要求时，也必须满足 <code>TextRepresentable</code> 协议的要求。在这个例子中，<code>PrettyTextRepresentable</code> 协议额外要求遵循协议的类型提供一个返回值为 <code>String</code> 类型的 <code>prettyTextualDescription</code> 属性。</p> <p>如下所示，扩展 <code>SnakesAndLadders</code>，使其遵循并符合 <code>PrettyTextRepresentable</code> 协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">extension</span> <span class="token class-name">SnakesAndLadders</span><span class="token punctuation">:</span> <span class="token class-name">PrettyTextRepresentable</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prettyTextualDescription<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> output <span class="token operator">=</span> textualDescription <span class="token operator">+</span> <span class="token string-literal"><span class="token string">&quot;:\n&quot;</span></span>
        <span class="token keyword">for</span> index <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">...</span>finalSquare <span class="token punctuation">{</span>
            <span class="token keyword">switch</span> board<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token keyword">let</span> ladder <span class="token keyword">where</span> ladder <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                output <span class="token operator">+=</span> <span class="token string-literal"><span class="token string">&quot;▲ &quot;</span></span>
            <span class="token keyword">case</span> <span class="token keyword">let</span> snake <span class="token keyword">where</span> snake <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                output <span class="token operator">+=</span> <span class="token string-literal"><span class="token string">&quot;▼ &quot;</span></span>
            <span class="token keyword">default</span><span class="token punctuation">:</span>
                output <span class="token operator">+=</span> <span class="token string-literal"><span class="token string">&quot;○ &quot;</span></span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> output
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>上述扩展令 <code>SnakesAndLadders</code> 遵循了 <code>PrettyTextRepresentable</code> 协议，并提供了协议要求的 <code>prettyTextualDescription</code> 属性。每个 <code>PrettyTextRepresentable</code> 类型同时也是 <code>TextRepresentable</code> 类型，所以在 <code>prettyTextualDescription</code> 的实现中，可以访问 <code>textualDescription</code> 属性。然后，拼接上了冒号和换行符。接着，遍历数组中的元素，拼接一个几何图形来表示每个棋盘方格的内容：</p> <ul><li>当从数组中取出的元素的值大于 <code>0</code> 时，用 <code>▲</code> 表示。</li> <li>当从数组中取出的元素的值小于 <code>0</code> 时，用 <code>▼</code> 表示。</li> <li>当从数组中取出的元素的值等于 <code>0</code> 时，用 <code>○</code> 表示。</li></ul> <p>任意 <code>SankesAndLadders</code> 的实例都可以使用 <code>prettyTextualDescription</code> 属性来打印一个漂亮的文本描述：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token function">print</span><span class="token punctuation">(</span>game<span class="token punctuation">.</span>prettyTextualDescription<span class="token punctuation">)</span>
<span class="token comment">// A game of Snakes and Ladders with 25 squares:</span>
<span class="token comment">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="类专属的协议"><a href="#类专属的协议" class="header-anchor">#</a> 类专属的协议</h2> <p>你通过添加 <code>AnyObject</code> 关键字到协议的继承列表，就可以限制协议只能被类类型采纳（以及非结构体或者非枚举的类型）。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">SomeClassOnlyProtocol</span><span class="token punctuation">:</span> <span class="token class-name">AnyObject</span><span class="token punctuation">,</span> <span class="token class-name">SomeInheritedProtocol</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里是类专属协议的定义部分</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在以上例子中，协议 <code>SomeClassOnlyProtocol</code> 只能被类类型采纳。如果尝试让结构体或枚举类型采纳 <code>SomeClassOnlyProtocol</code>，则会导致编译时错误。</p> <blockquote><p>注意</p> <p>当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。关于引用语义和值语义的更多内容，请查看 <a href="/pages/0641bb/#结构体和枚举是值类型">结构体和枚举是值类型</a> 和 <a href="/pages/0641bb/#类是引用类型">类是引用类型</a>。</p></blockquote> <h2 id="协议合成"><a href="#协议合成" class="header-anchor">#</a> 协议合成</h2> <p>要求一个类型同时遵循多个协议是很有用的。你可以使用<em>协议组合</em>来复合多个协议到一个要求里。协议组合行为就和你定义的临时局部协议一样拥有构成中所有协议的需求。协议组合不定义任何新的协议类型。</p> <p>协议组合使用 <code>SomeProtocol &amp; AnotherProtocol</code> 的形式。你可以列举任意数量的协议，用和符号（<code>&amp;</code>）分开。除了协议列表，协议组合也能包含类类型，这允许你标明一个需要的父类。</p> <p>下面的例子中，将 <code>Named</code> 和 <code>Aged</code> 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">protocol</span> <span class="token class-name">Aged</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token class-name">Named</span><span class="token punctuation">,</span> <span class="token class-name">Aged</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token class-name">Int</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function-definition function">wishHappyBirthday</span><span class="token punctuation">(</span>to celebrator<span class="token punctuation">:</span> <span class="token class-name">Named</span> <span class="token operator">&amp;</span> <span class="token class-name">Aged</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Happy birthday, </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">celebrator<span class="token punctuation">.</span>name</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">, you're </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">celebrator<span class="token punctuation">.</span>age</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> birthdayPerson <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Malcolm&quot;</span></span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">21</span><span class="token punctuation">)</span>
<span class="token function">wishHappyBirthday</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> birthdayPerson<span class="token punctuation">)</span>
<span class="token comment">// 打印 “Happy birthday Malcolm - you're 21!”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><code>Named</code> 协议包含 <code>String</code> 类型的 <code>name</code> 属性。<code>Aged</code> 协议包含 <code>Int</code> 类型的 <code>age</code> 属性。<code>Person</code> 结构体采纳了这两个协议。</p> <p><code>wishHappyBirthday(to:)</code> 函数的参数 <code>celebrator</code> 的类型为 <code>Named &amp; Aged</code>， 这意味着“任何同时遵循 Named 和 Aged 的协议”。它不关心参数的具体类型，只要参数遵循这两个协议即可。</p> <p>上面的例子创建了一个名为 <code>birthdayPerson</code> 的 <code>Person</code> 的实例，作为参数传递给了 <code>wishHappyBirthday(to:)</code> 函数。因为 <code>Person</code> 同时遵循这两个协议，所以这个参数合法，函数将打印生日问候语。</p> <p>这里有一个例子：将 Location 类和前面的 Named 协议进行组合：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">Location</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> latitude<span class="token punctuation">:</span> <span class="token class-name">Double</span>
    <span class="token keyword">var</span> longitude<span class="token punctuation">:</span> <span class="token class-name">Double</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>latitude<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">,</span> longitude<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>latitude <span class="token operator">=</span> latitude
        <span class="token keyword">self</span><span class="token punctuation">.</span>longitude <span class="token operator">=</span> longitude
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">City</span><span class="token punctuation">:</span> <span class="token class-name">Location</span><span class="token punctuation">,</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> latitude<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">,</span> longitude<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>latitude<span class="token punctuation">:</span> latitude<span class="token punctuation">,</span> longitude<span class="token punctuation">:</span> longitude<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function-definition function">beginConcert</span><span class="token punctuation">(</span><span class="token keyword">in</span> location<span class="token punctuation">:</span> <span class="token class-name">Location</span> <span class="token operator">&amp;</span> <span class="token class-name">Named</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Hello, </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">location<span class="token punctuation">.</span>name</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">!&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">let</span> seattle <span class="token operator">=</span> <span class="token class-name">City</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Seattle&quot;</span></span><span class="token punctuation">,</span> latitude<span class="token punctuation">:</span> <span class="token number">47.6</span><span class="token punctuation">,</span> longitude<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">122.3</span><span class="token punctuation">)</span>
<span class="token function">beginConcert</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> seattle<span class="token punctuation">)</span>
<span class="token comment">// 打印 &quot;Hello, Seattle!&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><code>beginConcert(in:)</code> 函数接受一个类型为 <code>Location &amp; Named</code> 的参数，这意味着“任何 Location 的子类，并且遵循 Named 协议”。在这个例子中，City 就满足这样的条件。</p> <p>将 birthdayPerson 传入 <code>beginConcert(in:)</code> 函数是不合法的，因为 Person 不是 Location 的子类。同理，如果你新建一个类继承于 Location，但是没有遵循 Named 协议，而用这个类的实例去调用 <code>beginConcert(in:)</code> 函数也是非法的。</p> <h2 id="检查协议一致性"><a href="#检查协议一致性" class="header-anchor">#</a> 检查协议一致性</h2> <p>你可以使用 <a href="/pages/757c02/">类型转换</a> 中描述的 <code>is</code> 和 <code>as</code> 操作符来检查协议一致性，即是否遵循某协议，并且可以转换到指定的协议类型。检查和转换协议的语法与检查和转换类型是完全一样的：</p> <ul><li><code>is</code> 用来检查实例是否遵循某个协议，若遵循则返回 <code>true</code>，否则返回 <code>false</code>；</li> <li><code>as?</code> 返回一个可选值，当实例遵循某个协议时，返回类型为协议类型的可选值，否则返回 <code>nil</code>；</li> <li><code>as!</code> 将实例强制向下转换到某个协议类型，如果强转失败，将触发运行时错误。</li></ul> <p>下面的例子定义了一个 <code>HasArea</code> 协议，该协议定义了一个 <code>Double</code> 类型的可读属性 <code>area</code>：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">protocol</span> <span class="token class-name">HasArea</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> area<span class="token punctuation">:</span> <span class="token class-name">Double</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如下所示，<code>Circle</code> 类和 <code>Country</code> 类都遵循了 <code>HasArea</code> 协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">Circle</span><span class="token punctuation">:</span> <span class="token class-name">HasArea</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> pi <span class="token operator">=</span> <span class="token number">3.1415927</span>
    <span class="token keyword">var</span> radius<span class="token punctuation">:</span> <span class="token class-name">Double</span>
    <span class="token keyword">var</span> area<span class="token punctuation">:</span> <span class="token class-name">Double</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pi <span class="token operator">*</span> radius <span class="token operator">*</span> radius <span class="token punctuation">}</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>radius<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">self</span><span class="token punctuation">.</span>radius <span class="token operator">=</span> radius <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Country</span><span class="token punctuation">:</span> <span class="token class-name">HasArea</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> area<span class="token punctuation">:</span> <span class="token class-name">Double</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>area<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">self</span><span class="token punctuation">.</span>area <span class="token operator">=</span> area <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>Circle</code> 类把 <code>area</code> 属性实现为基于存储型属性 <code>radius</code> 的计算型属性。<code>Country</code> 类则把 <code>area</code> 属性实现为存储型属性。这两个类都正确地遵循了 <code>HasArea</code> 协议。</p> <p>如下所示，<code>Animal</code> 是一个未遵循 <code>HasArea</code> 协议的类：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> legs<span class="token punctuation">:</span> <span class="token class-name">Int</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>legs<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">self</span><span class="token punctuation">.</span>legs <span class="token operator">=</span> legs <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>Circle</code>，<code>Country</code>，<code>Animal</code> 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 <code>AnyObject</code> 类型的值，存储在同一个数组中：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> objects<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">AnyObject</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token class-name">Circle</span><span class="token punctuation">(</span>radius<span class="token punctuation">:</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Country</span><span class="token punctuation">(</span>area<span class="token punctuation">:</span> <span class="token number">243_610</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Animal</span><span class="token punctuation">(</span>legs<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>objects</code> 数组使用字面量初始化，数组包含一个 <code>radius</code> 为 <code>2</code> 的 <code>Circle</code> 的实例，一个保存了英国国土面积的 <code>Country</code> 实例和一个 <code>legs</code> 为 <code>4</code> 的 <code>Animal</code> 实例。</p> <p>如下所示，<code>objects</code> 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否遵循 <code>HasArea</code> 协议：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">for</span> object <span class="token keyword">in</span> objects <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token keyword">let</span> objectWithArea <span class="token operator">=</span> object <span class="token keyword">as</span><span class="token operator">?</span> <span class="token class-name">HasArea</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Area is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">objectWithArea<span class="token punctuation">.</span>area</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Something that doesn't have an area&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// Area is 12.5663708</span>
<span class="token comment">// Area is 243610.0</span>
<span class="token comment">// Something that doesn't have an area</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>当迭代出的元素遵循 <code>HasArea</code> 协议时，将 <code>as?</code> 操作符返回的可选值通过可选绑定，绑定到 <code>objectWithArea</code> 常量上。<code>objectWithArea</code> 是 <code>HasArea</code> 协议类型的实例，因此 <code>area</code> 属性可以被访问和打印。</p> <p><code>objects</code> 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 <code>Circle</code>，<code>Country</code>，<code>Animal</code> 类型。然而，当它们被赋值给 <code>objectWithArea</code> 常量时，只被视为 <code>HasArea</code> 类型，因此只有 <code>area</code> 属性能够被访问。</p> <h2 id="可选的协议要求"><a href="#可选的协议要求" class="header-anchor">#</a> 可选的协议要求</h2> <p>协议可以定义<em>可选要求</em>，遵循协议的类型可以选择是否实现这些要求。在协议中使用 <code>optional</code> 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上 <code>@objc</code> 属性。标记 <code>@objc</code> 特性的协议只能被继承自 Objective-C 类的类或者 <code>@objc</code> 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</p> <p>使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 <code>(Int) -&gt; String</code> 的方法会变成 <code>((Int) -&gt; String)?</code>。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p> <p>协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似 <code>someOptionalMethod?(someArgument)</code> 这样，你可以在可选方法名称后加上 <code>?</code> 来调用可选方法。详细内容可在 <a href="/pages/96b368/">可选链式调用</a> 章节中查看。</p> <p>下面的例子定义了一个名为 <code>Counter</code> 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 <code>CounterDataSource</code> 协议定义，它包含两个可选要求：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token attribute atrule">@objc</span> <span class="token keyword">protocol</span> <span class="token class-name">CounterDataSource</span> <span class="token punctuation">{</span>
    <span class="token attribute atrule">@objc</span> <span class="token keyword">optional</span> <span class="token keyword">func</span> <span class="token function-definition function">increment</span><span class="token punctuation">(</span>forCount count<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span>
    <span class="token attribute atrule">@objc</span> <span class="token keyword">optional</span> <span class="token keyword">var</span> fixedIncrement<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>CounterDataSource</code> 协议定义了一个可选方法 <code>increment(forCount:)</code> 和一个可选属性 <code>fiexdIncrement</code>，它们使用了不同的方法来从数据源中获取适当的增量值。</p> <blockquote><p>注意</p> <p>严格来讲，<code>CounterDataSource</code> 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写。</p></blockquote> <p><code>Counter</code> 类含有 <code>CounterDataSource?</code> 类型的可选属性 <code>dataSource</code>，如下所示：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">var</span> dataSource<span class="token punctuation">:</span> <span class="token class-name">CounterDataSource</span><span class="token operator">?</span>
    <span class="token keyword">func</span> <span class="token function-definition function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> amount <span class="token operator">=</span> dataSource<span class="token operator">?</span><span class="token punctuation">.</span>increment<span class="token operator">?</span><span class="token punctuation">(</span>forCount<span class="token punctuation">:</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count <span class="token operator">+=</span> amount
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">let</span> amount <span class="token operator">=</span> dataSource<span class="token operator">?</span><span class="token punctuation">.</span>fixedIncrement <span class="token punctuation">{</span>
            count <span class="token operator">+=</span> amount
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>Counter</code> 类使用变量属性 <code>count</code> 来存储当前值。该类还定义了一个 <code>increment</code> 方法，每次调用该方法的时候，将会增加 <code>count</code> 的值。</p> <p><code>increment()</code> 方法首先试图使用 <code>increment(forCount:)</code> 方法来得到每次的增量。<code>increment()</code> 方法使用可选链式调用来尝试调用 <code>increment(forCount:)</code>，并将当前的 <code>count</code> 值作为参数传入。</p> <p>这里使用了两层可选链式调用。首先，由于 <code>dataSource</code> 可能为 <code>nil</code>，因此在 <code>dataSource</code> 后边加上了 <code>?</code>，以此表明只在 <code>dataSource</code> 非空时才去调用 <code>increment(forCount:)</code> 方法。其次，即使 <code>dataSource</code> 存在，也无法保证其是否实现了 <code>increment(forCount:)</code> 方法，因为这个方法是可选的。因此，<code>increment(forCount:)</code> 方法同样使用可选链式调用进行调用，只有在该方法被实现的情况下才能调用它，所以在 <code>increment(forCount:)</code> 方法后边也加上了 <code>?</code>。</p> <p>调用 <code>increment(forCount:)</code> 方法在上述两种情形下都有可能失败，所以返回值为 <code>Int?</code> 类型。虽然在 <code>CounterDataSource</code> 协议中，<code>increment(forCount:)</code> 的返回值类型是非可选 <code>Int</code>。另外，即使这里使用了两层可选链式调用，最后的返回结果依旧是单层的可选类型。关于这一点的更多信息，请查阅 <a href="/pages/96b368/#连接多层可选链式调用">连接多层可选链式调用</a>。</p> <p>在调用 <code>increment(forCount:)</code> 方法后，<code>Int?</code> 型的返回值通过可选绑定解包并赋值给常量 <code>amount</code>。如果可选值确实包含一个数值，也就是说，数据源和方法都存在，数据源方法返回了一个有效值。之后便将解包后的 <code>amount</code> 加到 <code>count</code> 上，增量操作完成。</p> <p>如果没有从 <code>increment(forCount:)</code> 方法获取到值，可能由于 <code>dataSource</code> 为 <code>nil</code>，或者它并没有实现 <code>increment(forCount:)</code> 方法，那么 <code>increment()</code> 方法将试图从数据源的 <code>fixedIncrement</code> 属性中获取增量。<code>fixedIncrement</code> 是一个可选属性，因此属性值是一个 <code>Int?</code> 值，即使该属性在 <code>CounterDataSource</code> 协议中的类型是非可选的 <code>Int</code>。</p> <p>下面的例子展示了 <code>CounterDataSource</code> 的简单实现。<code>ThreeSource</code> 类遵循了 <code>CounterDataSource</code> 协议，它实现了可选属性 <code>fixedIncrement</code>，每次会返回 <code>3</code>：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">ThreeSource</span><span class="token punctuation">:</span> <span class="token class-name">NSObject</span><span class="token punctuation">,</span> <span class="token class-name">CounterDataSource</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> fixedIncrement <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以使用 <code>ThreeSource</code> 的实例作为 <code>Counter</code> 实例的数据源：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
counter<span class="token punctuation">.</span>dataSource <span class="token operator">=</span> <span class="token class-name">ThreeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token omit keyword">_</span> <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">...</span><span class="token number">4</span> <span class="token punctuation">{</span>
    counter<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 3</span>
<span class="token comment">// 6</span>
<span class="token comment">// 9</span>
<span class="token comment">// 12</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上述代码新建了一个 <code>Counter</code> 实例，并将它的数据源设置为一个 <code>ThreeSource</code> 的实例，然后调用 <code>increment()</code> 方法 <code>4</code> 次。按照预期预期一样，每次调用都会将 <code>count</code> 的值增加 <code>3</code>.</p> <p>下面是一个更为复杂的数据源 <code>TowardsZeroSource</code>，它将使得最后的值变为 <code>0</code>：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">TowardsZeroSource</span><span class="token punctuation">:</span> <span class="token class-name">NSObject</span><span class="token punctuation">,</span> <span class="token class-name">CounterDataSource</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function-definition function">increment</span><span class="token punctuation">(</span>forCount count<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> count <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">1</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>TowardsZeroSource</code> 实现了 <code>CounterDataSource</code> 协议中的 <code>increment(forCount:)</code> 方法，以 <code>count</code> 参数为依据，计算出每次的增量。如果 <code>count</code> 已经为 <code>0</code>，此方法将返回 <code>0</code>，以此表明之后不应再有增量操作发生。</p> <p>你可以使用 <code>TowardsZeroSource</code> 实例将 <code>Counter</code> 实例来从 <code>-4</code> 增加到 <code>0</code>。一旦增加到 <code>0</code>，数值便不会再有变动：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>counter<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4</span>
counter<span class="token punctuation">.</span>dataSource <span class="token operator">=</span> <span class="token class-name">TowardsZeroSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token omit keyword">_</span> <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">...</span><span class="token number">5</span> <span class="token punctuation">{</span>
    counter<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// -3</span>
<span class="token comment">// -2</span>
<span class="token comment">// -1</span>
<span class="token comment">// 0</span>
<span class="token comment">// 0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="协议扩展"><a href="#协议扩展" class="header-anchor">#</a> 协议扩展</h2> <p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</p> <p>例如，可以扩展 <code>RandomNumberGenerator</code> 协议来提供 <code>randomBool()</code> 方法。该方法使用协议中定义的 <code>random()</code> 方法来返回一个随机的 <code>Bool</code> 值：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">extension</span> <span class="token class-name">RandomNumberGenerator</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function-definition function">randomBool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0.5</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现而无需任何额外修改：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> generator <span class="token operator">=</span> <span class="token class-name">LinearCongruentialGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Here's a random number: </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">generator<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// 打印 “Here's a random number: 0.37464991998171”</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;And here's a random Boolean: </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">generator<span class="token punctuation">.</span><span class="token function">randomBool</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// 打印 “And here's a random Boolean: true”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>协议扩展可以为遵循协议的类型增加实现，但不能声明该协议继承自另一个协议。协议的继承只能在协议声明处进行指定。</p> <h3 id="提供默认实现"><a href="#提供默认实现" class="header-anchor">#</a> 提供默认实现</h3> <p>可以通过协议扩展来为协议要求的方法、计算属性提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p> <blockquote><p>注意</p> <p>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p></blockquote> <p>例如，<code>PrettyTextRepresentable</code> 协议继承自 <code>TextRepresentable</code> 协议，可以为其提供一个默认的 <code>prettyTextualDescription</code> 属性来简单地返回 <code>textualDescription</code> 属性的值：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">extension</span> <span class="token class-name">PrettyTextRepresentable</span>  <span class="token punctuation">{</span>
    <span class="token keyword">var</span> prettyTextualDescription<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> textualDescription
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="为协议扩展添加限制条件"><a href="#为协议扩展添加限制条件" class="header-anchor">#</a> 为协议扩展添加限制条件</h3> <p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code> 子句来描述，正如 <a href="/pages/0d8a5e/#泛型-where-语句">泛型 Where 子句</a> 中所描述的。</p> <p>例如，你可以扩展 <code>Collection</code> 协议，适用于集合中的元素遵循了 <code>Equatable</code> 协议的情况。通过限制集合元素遵循 <code>Equatable</code> 协议， 作为标准库的一部分， 你可以使用 <code>==</code> 和 <code>!=</code> 操作符来检查两个元素的等价性和非等价性。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">extension</span> <span class="token class-name">Collection</span> <span class="token keyword">where</span> <span class="token class-name">Element</span><span class="token punctuation">:</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function-definition function">allEqual</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> element <span class="token operator">!=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>first <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如果集合中的所有元素都一致，<code>allEqual()</code> 方法才返回 <code>true</code>。</p> <p>看看两个整数数组，一个数组的所有元素都是一样的，另一个不一样：</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token keyword">let</span> equalNumbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> differentNumbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>由于数组遵循 <code>Collection</code> 而且整数遵循 <code>Equatable</code>，<code>equalNumbers</code> 和 <code>differentNumbers</code> 都可以使用 <code>allEqual()</code> 方法。</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code><span class="token function">print</span><span class="token punctuation">(</span>equalNumbers<span class="token punctuation">.</span><span class="token function">allEqual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 打印 &quot;true&quot;</span>
<span class="token function">print</span><span class="token punctuation">(</span>differentNumbers<span class="token punctuation">.</span><span class="token function">allEqual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 打印 &quot;false&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>注意</p> <p>如果一个遵循的类型满足了为同一方法或属性提供实现的多个限制型扩展的要求， Swift 会使用最匹配限制的实现。</p></blockquote></div></div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/05/07, 16:05:00</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/297d1c/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">扩展</div></a> <a href="/pages/0d8a5e/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">泛型</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/297d1c/" class="prev">扩展</a></span> <span class="next"><a href="/pages/0d8a5e/">泛型</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/742912/"><div>Homebrew+RVM+Ruby+CocoaPods</div></a> <span>11-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/81af2e/"><div>iOS13生命周期</div></a> <span>11-14</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/258164/"><div>《Swift编程语言》- 语法总结</div></a> <span>11-11</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div> <div class="comments-wrapper"><!----></div> </main></div> <!----> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">跟随系统</li><li class="iconfont icon-rijianmoshi">浅色模式</li><li class="iconfont icon-yejianmoshi">深色模式</li><li class="iconfont icon-yuedu">阅读模式</li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;filter:grayscale(100%);"></div> <!----> <div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f91ba302.js" defer></script><script src="/assets/js/2.dd713b59.js" defer></script><script src="/assets/js/3.069de0ac.js" defer></script><script src="/assets/js/33.b87269c8.js" defer></script>
  </body>
</html>